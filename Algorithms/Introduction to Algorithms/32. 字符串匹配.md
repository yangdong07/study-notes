主要内容
- 字符串匹配问题及相关概念，前缀，后缀
- 朴素的字符串匹配算法
- Rabin-Karp算法
- 有限自动机
- Knuth-Morris-Pratt算法

## 字符串匹配问题
字符串匹配问题的形式定义： 假设文本（text）是一个长度为 $n$ 的数组 $T[1..n]$，模式（pattern）是一个长度为 $m \le n$ 的数组 $P[1..m]$。
$P$ 和 $T$ 的元素都属于 字符集 $\Sigma$。

如果 $0 \le s \le n -m $，并且 $T[s+1 .. s+m] = P[1..m]$，则称模式$P$ 在文本 $T$ 中出现且**位移**为 $s$。
如果 $P$ 在 $T$ 中出现，且位移为 $s$，则称 $s$ 为一个**有效位移**，否则称为 **无效位移**。

字符串问题： 在一段指定的文本 $T$ 中，找出某指定模式 $P$ 出现的所有有效位移的问题。

字符串匹配问题有几种解决方法：

| 算法| 预处理时间 | 匹配时间 |
| :----|:-------------:| :-----:|
| 朴素算法 | 0 | $O((n-m +1)m)$ |
| Rabin-Karp | $\Theta(m)$ | $O((n-m +1)m)$ |
| 有限自动机算法 | $O(m \| \Sigma \|)$ | $\Theta(n)$ |
| Knuth-Morris-Pratt | $\Theta(m)$ | $\Theta(n)$ |

### 记号和术语
- $\Sigma * $表示所有有限长度的字符串的集合。
- 长度为0的**空字符串**用 $\epsilon$ 表示，$\epsilon \in \Sigma * $
- 字符串 $x$ 的长度 记为 $\left| x \right|$
- 两个字符串的连接 记为 $xy$，长度为 $|x| + |y|$
- 对字符串 $x, y, w  \in \Sigma*$，如果 $x = wy$，则称 $w$ 是$x$的**前缀**，记为 $w \sqsubset x$，并且有 $|w| \le |x|$
- 对字符串 $x, y, w  \in \Sigma*$，如果 $x = yw$，则称 $w$ 是$x$的**后缀**，记为 $w \sqsupset x$，并且有 $|w| \le |x|$
- **重叠后缀引理**：假设 $x, y, z$ 是满足 $x\sqsupset z$ 和 $y \sqsupset z$ 的三个字符串。
  - 如果 $|x| \le |y|$，则 $x \sqsupset y$；
  - 如果 $|x| \ge |y|$，则 $y \sqsupset x$；
  - 如果 $|x| = |y|$，则 $x =y$
- 把模式$P[1..m]$的前$k$ 个字符组成的前缀$P[1..k]$ 用 $P_k$ 表示。$P_0 = \epsilon$。

## 朴素的字符串匹配算法
基本步骤：
1. 遍历整个文本（所有位移）（$\Theta(n-m+1)$)
2. 检查$P$ 是否匹配 ($\Theta(m)$）

运行时间为 $O((n-m+1)m)$

## Rabin-Karp算法
Rabin-Karp主要在检查 $P$ 是否匹配上做了改进：并不是检查 $m$ 个字符。而是将$m$个字符变成一个模$q$ 的“数字”，然后直接比较。
对文本的前$m$ 个字符，需要用 $\Theta(m)$的时间处理，计算模$q$ 的值。在接下来的位移中，只需要去掉头一个字符，追加下一个字符，再计算模$q$的值，这样的操作只需要 $O(1)$的时间。

在比较过程中，有可能产生“伪命中”，即模 $q$ 值相同。这时候需要将字符串与$P$ 进行比较，时间为 $\Theta(m)$。

在最坏情况下，全部产生“伪命中”，则Rabin-Karp算法的运行时间为 $O((n-m+1)m)$。

但实际应用中，有效位移很少（例如只有常数 $c$ 个），算法的期望匹配时间为 $O((n-m+1) + cm) = O(n +m)$，在加上处理伪命中点所需的时间。
预计伪命中的次数为 $O(n/q)$， $v$ 为有效位移数。则算法的期望运行时间为 $$ O(n) + O(m(v + n/q)) $$ 如果 $v = O(1)$， $m \le n$，$m << q$，则算法期望的运行时间为 $O(n)$

## 有限自动机

一个**有限自动机$M$** 是一个5元组$(Q, q_0, A, \Sigma, \delta)$，其中：
- $Q$ 是**状态**的有限集合
- $q_0 \in Q$ 是**初始状态**
- $A \subseteq Q$ 是一个 **接受状态** 集合。
- $\Sigma$ 是**输入字母表**，也可以理解为输入集合，可以触发状态转移。
- $\delta$ 是一个从 $Q \times \Sigma$ 到$Q$ 的函数，称为 $M$ 的**（状态）转移函数**

如果有限自动机在状态 $q$ 时，读入了输入字符 $a$， 则它从状态 $q$ 变为状态 $\delta(q, a)$。
如果状态$q \in A$，则称自动机$M$ **接受了**迄今为止所读入的字符串。
没有被接受的输入称为**被拒绝**的输入。

有限自动机$M$ 可以推导出一个函数$\phi$，称为**终态函数**，它是从 $\Sigma*$ 到 $Q$ 的函数，并满足： $\phi(w)$ 是$M$ 在扫描字符串 $w$ 后终止时的状态。因此， $M$ 接受字符串$w$ 当且仅当 $\phi(w) \in A$。
$\phi$ 有下列递归关系定义：$$
\phi(\epsilon) = q_0 \\
\phi(wa) = \delta(\phi(w), a), \quad w \in \Sigma *, a \in \Sigma$$

### 字符串匹配自动机
对每个模式$P$ 都存在一个字符串匹配自动机。在预处理阶段，可以根据模式构造出相应的自动机。然后用自动机读入文本，当自动机进入可接受的状态时，则表示文本中出现了与模式匹配的字符串。
下面说明构造自动机的方法。

定义模式$P$ 的**后缀函数** $\sigma$ 是一个从 $\Sigma*$到 $\{0, 1, \cdots, m\}$ 上的映射： $$ \sigma(x) = \max{\{k : P_k \sqsupset x\}} $$ 即 $x$ 的后缀 $P$ 的最长前缀的长度。
给定模式 $P$，定义其对应的字符串匹配自动机：
- 状态集$Q$ 为 $\{0, 1, \cdots, m \}$
- 初始状态 $q_0 = 0$
- 接受状态集合 $A = \{m\}$，$m$ 是唯一的接受状态
- $\delta(q, a) = \sigma(P_qa)$

自动机对文本$T$ 进行扫描，有 $\delta(q, T[i]) = \sigma(P_qT[i])$ 。可以证明， 在自动机的操作中，始终保持如下条件不变：$$ \phi(T_i) = \sigma(T_i)$$ 当状态 $q = m$ 时，表示 $\phi(T_i) = \delta(T_i) = m$，$P_m = P \sqsupset T_i$，找到了一个匹配。

在使用 模式$P$和 字符集$\Sigma$ 构造 字符串匹配自动机的过程中，主要是计算所有的 $\delta(q, a)$。直观上看，这需要 $O(m | \Sigma|)$ 的预处理时间。
在匹配过程中只需要遍历一遍文本，状态转移的时间为 $O(1)$。所以匹配时间为 $\Theta(n)$

### Knuth-Morris-Pratt算法
Knuth，Morris和Pratt设计了一种线性时间字符串匹配算法。这个算法不用计算转移函数$\delta$，而是使用了一种 辅助函数 $\pi[1..m]$，它是在 $\Theta(m)$时间内，从模式$P$ 预先计算出来。
然后可以使用数组$\pi$ 在扫描过程中 实时有效的计算（在平摊意义上）转移函数 $\delta$。

定义模式$P$ 的**前缀函数 $\pi$** 是从 $\{1, 2, \cdots, m\}$ 到 $\{0, 1, \cdots, m-1\}$ 的映射： $$ \pi[q] = \max{\{ k: k < q \ \mathrm{and} \ P_k \sqsupset P_q \}}$$  即 $\pi[q]$ 是 $P_q$ 的真后缀  $P$的所有前缀 中的最长前缀的长度

对前缀函数 $\pi$ 进行迭代，就能够列举出是某给定前缀$P_q$的后缀 的所有前缀 $P_k$
定义 $$ \pi^*[q] = \{ \pi[q], \pi^{(2)}[q], \pi^{(3)}[q], \cdots, \pi^{(t)}[q] \}$$
其中 $\pi^{(i)}[q] = \pi[\pi^{(i-1)}[q]] $，是函数迭代。并且当 $\pi^{(t)}[q] = 0$ 时终止。
可以证明：$$ \pi^*[q] = \{k : k < q \ \mathrm{and} \ P_k \sqsupset P_q \}$$ 即 $\pi^*[q]$ 就是 为$P_q$的后缀 的所有前缀 $P_k$。

对$q = 1, 2, \cdots, m-1$，定义子集 $E_q \subseteq \pi^*[q] $ 为：$$
\begin{align}
E_q &= \{ k \in \pi^*[q]:  P[k+1] = P[q+1] \} \\
&= \{ k: k < q \ \mathrm{and} \ P_k \sqsupset P_q  \ \mathrm{and} \  P[k+1] = P[q+1] \} \\
&= \{ k: k < q \ \mathrm{and} \ P_{k+1} \sqsupset P_{q+1}  \} \\
\end{align}
$$ 可以证明 $$
\pi[q+1] = \left\{ \begin{array} {ll}
0 & if  \ E_{q} = \emptyset \\
1 + \max{\{k \in E_{q} \}} & if  \ E_{q} \neq \emptyset \\
\end{array} \right .
$$ 因此可以从 $E_q$ 得到 $\pi[q+1]$。 从 $\pi[1] = 0$ 开始，可以通过迭代获得所有的 $\pi$ 值。

KMP算法使用 $\pi$ 函数来“实时”计算 $\delta$ 值。
定义集合  $E'_{q, a} $ 为：$$
\begin{align}
E'_{q, a} &= \{ k \in \pi^*[q]:  P[k+1] = a \} \\
&= \{ k: k < q \ \mathrm{and} \ P_k \sqsupset P_q  \ \mathrm{and} \  P[k+1] = a \} \\
&= \{ k: k < q \ \mathrm{and} \ P_{k+1} \sqsupset P_qa  \} \\
\end{align}
$$ 可以证明$$
\delta(q, a) = \sigma(P_qa) = \left\{ \begin{array} {ll}
0 & if  \ E'_{q,a} = \emptyset \\
1 + \max{\{k \in E'_{q,a} \}} & if  \ E'_{q,a} \neq \emptyset \\
\end{array} \right .
$$ 实际上就是 $\sigma(P_qa)$ 的定义：$P_qa$ 的后缀 $P_k$ 的最大前缀的长度。
因此，KMP仅仅通过迭代$\pi[q]$ 并与比较 $a$ 即可以得到 $\delta(q,a)$ 的值。

使用平摊分析方法，KMP算法的预处理时间为$\Theta(m)$， 匹配时间为 $\Theta(n)$。

_KMP算法有另外的解释意义，本质上在扫描过程中对于一个位移 $s$，如果只有$q$ 个字符匹配，下一次扫描可以直接跳到 $s' = s + q - \pi[q]$ 位移上进行处理。但是跳转隐藏在状态函数的转移上了_。
