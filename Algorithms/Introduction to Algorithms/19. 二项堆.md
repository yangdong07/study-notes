


可合并堆（mereable heap），支持以下操作：
- $\text{MAKE-HEAP}()$：创建一个空堆
- $\text{INSERT}(H, x)$：插入
- $\text{MINIMUM}(H)$：返回最小关键字结点指针（对应最小堆；反之对应最大堆）
- $\text{EXTRACT-MIN}(H)$：取出最小关键字结点（同样对应最小堆）
- $\text{UNION}(H_1, H_2)$：合并 $H_1$和$H_2$

此外二项堆和斐波那契堆还支持：
- $\text{DECREASE-KEY}(H, x, k)$：将新的关键字值 $k$ 赋给 $x$。
- $\text{DELETE}(H,x)$：删除结点 $x$

之前的二叉堆也可以合并，但是需要遍历所有元素，运行时间为 $\Theta(n)$。


## 二项树
二项树 $B_k$ 是一种递归定义的有序树。
二项树 $B_0$ 只包含一个结点。
二项树 $B_k$ 由两棵二项树 $B_{k-1}$ 连接而成。其中一棵树的根是另一棵树的根的最左孩子。

二项树 $B_k$ 具有以下性质
1. 共有 $2^k$ 个结点
2. 树的高度为 $k$
3. 在深度 $i$ 处恰有  ${k \choose i}$  个结点，其中 $i=0, 1, 2, \cdots, k $
4. 根的度数为 $k$，它大于任何其他结点的度数；并且，如果根的子女从左到右编号为 $k-1, k-2, \cdots, 0$， 子女 $i$ 是子树 $B_i$ 的根。

在一棵包含 $n$ 个结点的二项树中，任意结点的最大度数为 $\lg n$

## 二项堆
二项堆 $H$ 由若干二项树组成，满足以下性质：
1. $H$ 中的每个二项树遵循最小堆性质： 结点的关键字大于或等于其父结点的关键字。这种树称为 ** 最小堆有序 ** 的。 每棵最小堆有序的二项树的根包含了树中最小的关键字。
2. 对任意非负整数 $k$，在$H$ 中至多有一棵二项树，其根具有度数 $k$。

解释一下第2个性质：实际上是要求二项堆中每棵二项树的根的度数都不相同。如果二项堆 $H$ 有 $n$ 个结点，可以将 $n$ 用二进制表示，有 $\lfloor \lg n \rfloor + 1$ 位，例如 $ \langle b_{\lfloor \lg n \rfloor}, b_{\lfloor \lg n \rfloor - 1}, \cdots, b_0 \rangle $， $n = \sum_{i=0}^{\lfloor \lg n \rfloor}{b_i2^i}$。由二项树性质1，二项树 $B_i$ 出现在 $H$ 中，当且仅当 位 $b_i = 1$。 所以二项堆 $H$ 至多有 $\lfloor \lg n \rfloor + 1$ 棵二项树。

### 二项堆的表示
二项树用左孩子、右兄弟方式。
$H$ 具有域：
- $\textit{head}$，指向第一棵二项树的根结点

每个二项树的结点的域：
- $\textit{degree}$，结点的度（子女数）
- $\textit{child}$，左孩子指针
- $\textit{sibling}$，右兄弟指针。对于每个二项树的根结点来说，右兄弟指向下一棵二项树的根。由根组成的链表称为根表。根表的根的度数是严格递增的。
- $\textit{p}$，父结点指针。

## 二项堆的操作

### $\text{MAKE-HEAP}()$
$\Theta(1)$

### 寻找最小关键字
需要遍历根表（最多$\lfloor \lg n \rfloor + 1$ 个二项树的根）， 运行时间 $O(\lg n)$

### $\text{UNION}(H_1, H_2)$ 合并两个二项堆 $H_1, H_2$
因为要维持二项堆性质，类似于二进制加法，把具有相同大小的二项树 $B_k$ 合并成 $B_{k+1}$。
算法主要步骤：
1. 把两个二项堆里的所有二项树按照根度数递增，构成一个新的堆 $H$。此时这个堆里的 二项树的根的度数可能有重复的。
2. 从第一棵树开始，类似二进制加法，遇到相同大小的二项树 $B_k$，执行合并二项树操作。

注意一些细节：
指针从第一棵树开始，有以下几种情况：
1. 当前树与下一棵树的大小不同，相当于 1 + 0，不用操作，指针直接指向下一棵树。
2. 当前树与下一棵树的大小相同，且与下下棵树的大小也相同，相当于 1 + 1 + 1，也不用操作，指针直接指向下一棵树，执行后面的加法和进位。
3. 当前树与下一棵树的大小相同，且与下下棵树的大小不同，相当于 1 + 1 + 0，此时需要合并树，根据这两棵树的根结点的关键字大小决定谁的根仍然作为新树的根。

合并操作只处理树的根结点，运行时间为 $O(\lg n)$， $n$ 为所有元素数量。  

### $\text{INSERT}(H, x)$ 插入一个结点
主要步骤：
1. 构建一个新堆，只有待插入的结点。 $O(1)$
2. 将 $H$ 与新堆 执行 UNION 操作。  $O(\lg n)$


### $\text{EXTRACT-MIN}(H)$ 取出具有最小关键字的结点
主要步骤：
1. 从根表中找到最小关键字结点， $O(\lg n)$
2. 把该二项树从二项堆中移出，打散，构成一个新的堆 $H'$， $O(\lg n)$
3. 合并 $H$ 和 $H'$， $O(\lg n)$

### $\text{DECREASE-KEY}(H, x, k)$ 减小关键字的值
这里已知结点的指针 $x$，主要在树中操作，将 $x$ 冒泡上移。
由于树的深度最多为 $O(\lg n)$，运行时间为 $O(\lg n)$

### $\text{DELETE}(H,x)$ 删除一个关键字
主要步骤：
1. 先执行 $\text{DECREASE-KEY}(H, x, -\infty)$。 $-\infty$ 可以是关键字取值空间中最小的值。
2. 然后执行 $\text{EXTRACT-MIN}(H)$，取出这个最小的关键字的结点。
