
实现字典的一种有效数据结构为 **散列表（hash table）**
在 $O(1)$ 时间内访问任意元素。

## 直接寻址表
关键字的全域 $U=\{0, 1, ..., m-1\}$
数组（直接寻址表） $T[0..m-1]$ ，每个位置（slot）对应全域里的一个关键字。

## 散列表
如果域 $U$ 很大，实际存储的关键字集合 $K$ 相对 $U$可能较小。
定义**散列函数 $h$**，根据关键字 $k$ 计算出槽的位置：
$$ h: U \to \{0, 1, ..., m - 1\}$$

**碰撞 collision**： 两个关键字可能映射到同一个槽上。

### 链接法解决碰撞
在链接法里，把散列（hash）到同一个槽的所有元素放到一个链表中。

### 链接法散列的分析
**装载因子 load factor**： 给定一个能存放 $n$个元素的、具有 $m$个槽位的散列表 $T$，定义 $T$的装载因子 $\alpha = n/m$，即一个链中平均存储的元素数。

** 简单一致散列（simple uniform hashing）**： 任何元素等可能的散列到 $m$ 个槽，且与其他元素已被散列到什么位置上是独立无关的。

**定理11.1 在简单一致散列的假设下，对用链接解决碰撞的散列表，一次不成功的查找的期望时间为 $\Theta(1+\alpha)$**

**定理11.2 在简单一致散列的假设下，对用链接解决碰撞的散列表，一次成功的查找的期望时间为 $\Theta(1+\alpha)$**


## 散列函数
一个好的散列函数应（近似的）满足简单一致散列的假设。
### 触发散列
$$ h(k) = k \mod m$$
其中 $m$ 常选与2的整数幂不太接近的质数

### 乘法散列
$$ h(k) = \lfloor m (kA \mod 1) \rfloor $$
其中  $0 < A < 1$
优点是 对 $m$ 的选择没有特别要求，一般选为 2的某个幂次
$A \approx (\sqrt5 -1)/2 = 0.6180339887\cdots $

### 全域散列 universal hashing
定义： 设 $\mathcal{H}$ 为有限的一组散列函数，将给定关键字域 $U$ 映射到 $\{0, 1, \cdots, m - 1\}$ 中。这样的一个函数组称为是全域的（universal），如果对每一对不同的关键字 $k, l \in U$，满足 $h(k) = h(l)$的散列函数 $h \in \mathcal{H}$ 的个数至多为 $|\mathcal{H}| / m$。
换言之，随机从 $\mathcal{H}$中选出一个散列函数，当关键字$k \neq l$时，两者发生碰撞的概率不大于 $1/m$。

全域散列的定义似乎要求对 $\mathcal{H}$中每一个散列函数都能产生简单一致散列。

#### 全域散列函数类
选择一个足够大的质数 $p$，每个关键字$k$ 都落在 0 到 $p-1$的范围内（包括0和$p-1$）。
设 $Z_p = \{0, 1, \cdots, p -1 \}$, $Z^{*}_p = \{1, \cdots, p -1 \}$
对于任何 $a\in Z^{*}_p$ 和任何 $b\in Z_p$，定义散列函数 $h_{a,b}$：
$$h_{a,b} = ((ak+b)\mod p)\mod m  \\
\mathcal{H_{p,m}} = \{h_{a, b} : a\in  Z^{*}_p , b \in Z_p\}$$


## 开放寻址法（open addressing）
在开放寻址法里，要插入一个元素，可以连续的检查散列表的各项，直到找到一个空槽来放置待插入的关键字。

对开放寻址法，对每一个关键字{k}，探查序列
$$ \langle h(k, 0), h(k, 1), \cdots, h(k, m-1) \rangle$$
必须是 $\langle 0, 1, \cdots, m - 1 \rangle$ 的一个排列。

这样才能在发生碰撞的情况下找到空槽。直到散列表被全部填满。

**一致散列假设**：假设每个关键字的探查序列是 $\langle 0, 1, \cdots, m - 1 \rangle$ 的 $m!$ 种排列中的任一个的可能性相同。

### 线性探查 linear probing
$$h(k, i) = (h'(k)+i) \mod m, i = 0, 1, \cdots, m-1$$

一次群集（primary clustering）：随着时间推移，连续被占用的槽不断增加。

### 二次探查 quadratic probing
$$h(k, i) = (h'(k) + c_1i + c_2i^2) \mod m$$
二次群集（secondary clustering）

### 双重散列
$$h(k, i) = (h_1(k) + ih_2(k))\mod m$$
为能查找整个散列表 $h_2(k)$ 要与表的大小 $m$ 互质。
双重散列法中用了 $\Theta(m^2)$ 种探查序列，而线性或二次探查中用了 $\Theta(m)$ 种。

### 开放寻址法分析

对一个装载因子为 $\alpha < 1 $的散列表，在**一致散列**的假设下，
1. 一次不成功的查找中，期望探查次数至多为 $1/(1-\alpha)$。
2. 插入一个元素时，至多需要做$1/(1-\alpha)$次探查。
3. 一次成功查找的期望探查数至多为 $$\frac1\alpha \ln \frac1{1-\alpha}$$

## 完全散列（perfect hashing）
当关键字集合是静态的时，散列技术还可以或得出色的最坏情况性能。
两级散列方案，每一级上都采用全域散列
第一级散列：利用从某一全域散列函数簇中仔细选出的一个散列函数 $h$，将 $n$ 个关键字散列到 $m$ 个槽中。
第二级散列：对于散列到槽 $j$ 的所有关键字，使用一个较小的二次散列表 $S_j$，与其相关的散列函数为 $h_j$。通过仔细的选取散列函数$h_j$，可以确保在第二级上不出现碰撞。
为了能真正确保在第二级上不出现碰撞，需要让散列表 $S_j$ 的大小$m_j$ 为散列到槽 $j$ 的关键字数$n_j$ 的平方。

期望的总体存储空间（主散列表和所有的二次散列表所占用的空间）为 $O(n)$

**定理11.9 如果利用一个从全域散列函数簇中随机选出的散列函数 $h$，将$n$ 个关键字存储在一个大小为 $m = n^2$ 的散列表中，出现碰撞的概率小于 $1/2$**
注意这里的问题：出现碰撞的概率小于 $1/2$ 而不是等于0。这是随机而论的。需要做的是，仔细的选择一个散列函数 $h$，使得在 $m = n^2$大小的散列表里不发生碰撞，这是可以做到的，因为关键字集合是静态的。

对于一级散列，可以令 $m = n$，在二级散列上，令 $m_j = n^2_j$。实际上其期望的总体存储空间为 $O(n)$
