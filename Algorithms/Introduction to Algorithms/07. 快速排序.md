
归类：
- 就地排序
- 合并排序


## 快速排序基本原理

**分解**：数组 $A[p..r]$被划分成两个（可能空）子数组 $A[p..q-1]$ 和 $A[q+1..r]$，使得 $A[p..q-1]$中的每个元素都小于等于 $A(q)$，$A[q+1..r]$中的每个元素都比 $A(q)$大。

**解决**：通过递归调用快速排序，对子数组 $A[p..q-1]$ 和 $A[q+1..r]$ 排序

**合并**：因为两个子数组是就地排序的，将它们的合并不需要操作：整个数组 $A[p..r]$ 已排序


快速排序算法：
```
QUICKSORT(A, p, r)
  if p < r
    q = PARTITION(A, p, r)
    QUICKSORT(A, p, q-1)
    QUICKSORT(A, q+1, r)
```

其中的关键步骤是 PARTITION 过程，如下所示：
```
PARTITION(A, p, r)
  x = A[r]
  i = p - 1
  for j in [p .. r-1]
    if A[j] <= x
      i = i + 1
      swap(A[i], A[j])
  swap(A[i+1], A[r])
  return i+1
```
语言描述就是：
1. 选择一个元素作为主元（pivot element），这里选最后一个$A[r]$
2. 定义一个界标 $i = p - 1$ 和游标 $j = p$
3. 按游标取每个元素（$A[j]$）与主元比较。如果元素小于等于主元，则界标+1，$A[j]$ 与界标元素 $A[i]$交换。
4. 最后把主元与界标下一个元素交换 ： $swap(A[i+1], A[r])$

这样，所有不大于主元的元素都在界标左边，所有大于主元的元素都在界标右边。完成了快速排序里的关键划分。


## 快速排序性能
快速排序的最坏情况发生在所有划分都是不对称的，例如已经排序的数组。这时候的运行时间为 $\Theta(n^2)$
如果所有划分都是相对对称，则快速排序的运行时间为 $O(n\lg{n})$
完全不对称的情况很少发生。如果不对称比例固定（例如9：1或99：1），快速排序的运行时间也是 $O(n\lg{n})$

## 快速排序的随机化版本
在选择主元的时候，随机选取。
```
RANDOMIZED-PARTITION(A, p, r)
  i = RANDOM(p, r)
  swap(A[r], A[i])
  return PARTITION(A, p, r)
```

## 快速排序分析
可以数学证明：
QUICKSORT的最坏运行时间为 $\Theta(n^2)$
使用 RANDOMIZED-PARTITION ，快速排序算法的期望运行时间为 $O(n\lg{n})$
