主要内容
- 抽象问题、具体问题、判定问题、最优化问题
- 形式语言体系
- 问题归约
- P类、NP类、NPC类定义
- NP完全
- 第一个NP完全问题：电路可满足性问题
- 其他NP完全问题：公式可满足性、3-CNF可满足性、团问题、顶点覆盖、哈密顿回路、旅行商问题、子集和问题

NP这一名称代表“非确定性多项式时间（nondeterministic polynomial time）”。多项式时间可解的问题一般被看做是易处理的，其原因是哲学方面的。其中一点原因是，多项式时间可解问题类具有很好的封闭性，这是因为在加法、乘法和组合运算下，多项式是封闭的。

多项式时间可解的问题属于 P类问题。
NP类问题到目前为止还没有发现多项式时间解决的算法，但不代表没有，所以称为非确定性多项式时间类问题。
对NP完全问题，如果有一个问题找到了多项式时间解决的算法，则所有NP完全问题都能在多项式时间内解决。

## 基本概念

### 抽象问题和具体问题
**抽象问题** $Q$ 是在问题**实例**集合 $I$ 和问题**解法**集合$S$ 上的一个二元关系。

**判定问题（decision problem）** 即那些解为“是”或“否”的问题，抽象判定问题可以看做是从 $I$ 到 解集$\{0, 1\}$ 上的函数。

**最优化问题**中，必须最大化或最小化某个量。但在NP理论中，常常将最优化问题转化成一个判定问题。例如在“最短路径”问题中，找到两点间的最短路径，可以转化成判定问题：两点之间是否至多 $k$ 条边。

**编码**：如果要用计算机程序求解一个抽象问题，就必须用一种程序能理解的方式来表示问题实例。抽象对象集合$S$ 的**编码**是从 $S$ 到二进制串集合的映射 $e$。

**具体问题**：实例集为二进制串集合称为**具体问题**。如果提供给一个算法的是长度$n=|i|$ 的一个问题实例$i$ 时，算法可以在 $O(T(n))$ 时间内产生问题的解，我们就说该算法在时间 $O(T(n))$ 内解决了该具体问题。

**多项式时间可解**：如果一个算法能在时间$O(n^k)$（$k$ 是一个常数）内求解出某具体问题，就说该具体问题是**多项式时间可解的**。

**复杂类$\mathbf{P}$**：是在多项式时间内可解的具体判定问题的集合。

一般将抽象问题的实例集进行二进制编码： 假定一个整数的编码与其二进制表示是**多项式相关的**，并且一个有限集合的编码与其元素的编码是多项式相关的。这里**多项式相关**是指可以在多项式时间内编码和反编码。这样一种编码为标准编码，用尖括号括起来。例如图问题的实例 $G$的标准编码为 $\langle G \rangle$。求解一个问题的效率不应依赖于问题的编码。

### 形式语言体系
**字母表$\Sigma$**是符号的有限集合。
字母表$\Sigma$ 上的**语言$L$** 是由 $\Sigma$ 中的符号组成的串的任意集合。
**空串**用$\epsilon$表示
**空语言**用 $\phi$ 表示
$\Sigma$ 上所有串构成的语言表示为 $\Sigma^*$
$\Sigma$ 上每个语言$L$ 都是 $\Sigma^*$ 的一个子集。

从语言理论的观点来看：任何判定问题$Q$ 的实例集合即 $\Sigma^*$，其中 $\Sigma= \{0, 1\}$。因为$Q$ 是那些答案为1（是）的问题实例来描述的，因此可以把 $Q$ 看做是定义在 $\Sigma = \{0, 1\}$ 上的一个语言 $L$，其中 $$L = \{ x\in \Sigma^*: Q(x) = 1\}$$ 例如，判定问题 PATH 对应的语言为
$ \text{PATH} = \{ \langle G, u, v, k \rangle: G = (V, E) 是一个无向图, u, v\in V, k \ge 0 是一个整数, 图 G 中从u 到v 存在一条长度至多为k 的路径.\}$

> _注：问题可以看做是一个语言。每个问题实例可以编码为$\{0, 1\}^*$，问题中带有编码的具体意义。但为什么说问题是那些答案为1的问题实例来描述的？是否仅仅只是一个描述，真正有意义的是 $\langle G, u, v, k \rangle $。_
_算法接受语言，仅仅是对输入计算，输出的 1 的意义是什么呢？ 表示 $\langle G, u, v, k \rangle$ 的解为 1，还是表示对 $\langle G, u, v, k\rangle$ 的描述是正确的？这两者似乎是等价的_
_此外还有个疑点：如果限定了 $Q(x) = 1$，似乎就限制了实例集合。感觉并不能完全描述问题的实例集合。_
注意：判定问题，与其相对应的语言。还是按这样理解：对一个判定问题对应的语言，如果算法接受，则表示判定问题的答案为1（是）。如果算法不能在多项式时间内接受，则说明判定问题的答案为0（否）。这样，判定问题对应的语言仅仅是描述；判定问题对应的语言的串应当是所有具体实例。一个问题属于P类还是NP类，则看是否多项式时间内可接受，或者可验证。
关于$Q(x) =1$，确实有这个限定。那么应当这样理解：我们关心的是答案为1的判定问题，能不能在多项式时间内被某个算法接受，而并不关心答案本身。所以，定义判定问题的语言为答案为1的问题实例。


形式语言体系可以用来表述判定问题与求解这些问题的算法之间的关系。
如果对给定输入 $x$ ，算法输出$A(x) = 1$，我们就说算法 $A$ **接受** 串$x \in \{0, 1\}^*$。串的集合 $L = \{ x\in \{0, 1\}^*: A(x) = 1\}$ 是被算法$A$ **接受**的语言。如果 $A(x) = 0$，则说算法 $A$ **拒绝**串 $x$。

即使算法$A$ 接受了语言 $L$，也不一定会拒绝$x \notin L$：有可能无限循环而不输出。

如果$L$ 中的每个二进制串要么被算法 $A$ 接受，要么被其拒绝，则说语言 $L$ 是由算法 $A$**判定**。 相应的，有**多项式时间接受**和**多形式时间判定**的概念。

可以非形式的定义一个**复杂性类（complexity class）**为语言的一个集合。
某一语言是否属于该集合，可以通过某种**复杂性度量（complexity measure）**来确定。比如一个算法的运行时间。

关于复杂性类P，按照复杂性度量，有另一种定义：
$\mathrm{P} = \{ L \subseteq \{0, 1\}^*: 存在一个算法A能在多项式时间内判定 L \}$
可以证明：
$\mathrm{P} = \{ L \subseteq \{0, 1\}^*: L能被一个多项式时间算法所接受 \}$
> 这样，如果$L$ 是一个判定问题对应的语言，$L$ 能被一个多项式时间算法所接受，那么对 $x\notin L$，定义一个多项式时间界，如果不能在这个时间界接受，则输出$A(x) = 0$。 这样，对于判定问题和其相应语言来说，只包含答案为1的问题实例是有意义的。我们可以说某个问题$Q \in P$，或者$Q \in NP$。 当然以语言复杂性度量的第一种定义，应该是最基础的定义。这个语言里，可能包含了具体判定问题的所有实例。

### 多项式时间验证
在路径问题中，给出一个实例 $\langle G, u, v, k \rangle$，同时也给出一条从 $u$ 到$v$ 的路径 $p$。我们可以检查$p$ 的长度是否至多为 $k$。如果是的，则可以把$p$ 看做是该实例的确属于 PATH 的“**证书（certificate）**“。
**验证算法**是一个含两个自变量的算法 $A$，其中一个自变量是普通输入串 $x$，另一个是称为“证书”的二进制串 $y$。 如果存在一个证书$y$ 满足 $A(x, y)= 1$，则称算法 $A$ **验证了**输入串 $x$。由 $A$ 验证的语言为： $$ L = \{x \in \{0, 1\}^*: 存在 y \in \{0, 1\}^*, 满足 A(x, y) = 1\}$$

**复杂类NP 是能被一个多项式时间算法验证的语言类**。一个语言 $L$ 属于 $NP$，当且仅当存在一个两输入的多项式时间算法$A$ 和常数 $c$ 满足： $$ L = \{x \in \{0, 1\}^*: 存在 y（ |y| = O(|x|^c)）, 满足 A(x, y) = 1\}$$ 称算法$A$ 在**多项式时间内验证了**语言$L$。

$P \subseteq NP$，但是不能确定 $P = NP$。

## NP完全性与可归约性
### 可归约性
语言 $L_1$ 在多项式时间内可以归约为语言 $L_2$，写作 $L_1 \le_P L_2$
如果存在一个**多项式时间可计算**的函数 $f: \{0, 1\}^* \to \{0, 1\}^*$，满足对所有的 $x\in \{0, 1\}^* $，都有 $$ x\in L_1 \leftrightarrow f(x) \in L_2$$  则称函数 $f$ 为**归约函数**。计算 $f$ 的多项式时间算法 $F$ 为**归约算法**。

### NP完全性
对语言 $L \subseteq \{0, 1\}^*$， 如果：
1. $L \in \text{NP}$
2. 对每一个 $L' \in \text{NP}$， 有 $L' \le_P L$

则称 $L$ 是**NP完全的**，$L \in \text{NPC}$
如果一种语言$L$ 满足性质2，但不一定满足性质1，则成$L$ 是 NP难度（NP hard）的。
NPC是NP完全语言类。

**如果任何NP完全问题是多项式时间可求解的，则 P = NP**
**如果NP中的任何问题不是多项式时间可求解的，则所有NP完全问题都不是多项式时间可求解的**

### 电路可满足性问题
circuit satisifiability
给定一个由与、或和非门构成的一个布尔组合电路，它是可满足的么？（可满足指存在一组布尔输入值，使得电路具有一个**可满足性赋值**，即输出为1）
形式语言定义为：
$$ \text{CIRCUIT-SAT} = \{ \langle C \rangle: C 是一个可满足的布尔组合电路 \}$$

该问题是多项式时间可验证的，验证时间是 $C$ 的规模的多项式。所以 $ \text{CIRCUIT-SAT} \in \text{NP} $
另，可以证明，所有 NP 问题都可以归约（通过计算机电路转换） 成电路可满足性问题，所以 CIRCUIT-SAT 是NP完全问题。

**如果$L$ 是一种满足对某个 $L'\in \text{NPC}$， 有 $L' \le_P L$ 的语言，则$L$ 是NP难度的。此外，如果$L \in \text{NP}$，则$L \in \text{NPC}$。**
就是说，对一个问题，如果可以用一个已知的NPC问题多项式时间归约到这个问题，则这个问题是NP难度的。如果这个问题还是多项式可验证的，则它也是NP完全问题。所以我们可以用已知NP完全问题归约的方法，证明其他问题是NP完全问题。

### 公式可满足性问题
SAT的一个实例就是一个由下列成分组成的布尔公式 $\phi$：
1. $n$ 个布尔变量： $x_1, x_2, \cdots, x_n$；
2. $m$ 个布尔连接词： 布尔连接词（一个或两个输入，一个输出的布尔函数），如 $\land$、$\lor$、$\lnot$、$\to$、$\leftrightarrow$
3. 括号

关于一个布尔公式$\phi$ 的**真值赋值**是为 $\phi$ 中各变量所取的一组值；
**可满足性赋值**是指使公式 $\phi$ 的值为1的真值赋值。
具有**可满足性赋值**的公式就是**可满足公式**
公式可满足性问题即： 一个给定的布尔公式是不是可满足的？
其形式语言为： $$\text{SAT} = \{ \langle \phi \rangle: \phi 是一个可满足布尔公式 \}$$

可以将电路可满足性问题的每个实例，在多项式时间内归约成公式可满足性问题，来证明公式可满足性问题是NP完全的。
举个归约的例子，对于一个简单的布尔电路逻辑：$x_5 = x_1 \land x_2, x_6 = x_3 \land x_4, x_7 = x_5 \lor x_6 $，其中 $x_1, x_2,x_3, x_4$ 是电路输入， $x_7$ 是电路输出， $x_5, x_6$ 是中间线路，则有逻辑 $  x_7 = (x_1 \land x_2) \lor (x_3 \land x_4)$  
更一般的，我们完全按照电路可以写出布尔公式： $$ \begin{align}
\phi = x_7 &\land (x_7 \leftrightarrow (x_5 \lor x_6)) \\
&\land (x_5 \leftrightarrow (x_1 \land x_2)) \\
&\land (x_6 \leftrightarrow (x_3 \land x_4)) \\
\end{align} $$  可以看出，这个公式完全描述了各个电路单元的状态，与电路是完全等价的。并且是多项式时间归约的（电路的规模）。

### 3-CNF可满足性

布尔公式中的一个**文字（literal）**是指一个变量或变量的“非”。
如果一个布尔公式可以表示为所有**子句（clause）**的“与”，且每个子句都是一个或多个文字的“或”，则称该布尔公式为**合取范式**，或CNF（conjunctive normal form）。
如果公式中每个子句恰好都有三个不同的文字，则称该布尔公式为**3合取范式**，或3-CNF。
例如布尔公式 $(x_1 \lor \lnot x_1 \lor \lnot x_2) \land (x_3 \lor x_2 \lor x_4) \land (x_1 \lor x_3 \lor \lnot x_4) $ 是一个3合取范式。

3-CNF可满足性问题即，对于一个3-CNF形式的布尔公式 $\phi$，是否是可满足的？其形式语言定义为：
$$ \text{3-CNF-SAT} = \{ \langle \phi \rangle: \text{3-CNF}形式的\phi 是一个可满足布尔公式 \}$$

可以将任意公式转换成一个 3-CNF 合取范式的形式，所需时间是多项式时间。因此，可以证明，**3-CNF可满足性问题是NP完全问题。**

具体转换略，大致步骤是
1. 为输入公式构造一棵二叉“语法分析树”。每个叶子是变量，每个结点是布尔连接词。引入变量$y_i$ 作为每个内部顶点的输出。可以将公式重写成 若干子句的“与”的形式（合取式）。 且每个子句至多3个文字。
2. 对每个子句，利用真值表，可以构造出公式的**析取范式（disjunctive normal form，DNF）**，然后转成合取范式。
3. 处理不足3个文字的子句。


### 团问题
无向图 $G=(V, E)$ 中的团（clique）是一个顶点子集 $V'\subseteq V$，其中每一对顶点之间都由 $E$ 中的一条边相连。
团问题是关于寻找图中规模最大的团的最优化问题。可以转化成判定问题：在图中是否存在一个给定规模为 $k$ 的团？ 其形式定义为： $$ \text{CLIQUE} = \{ \langle G, k \rangle: G 是具有规模为 k 的团的图 \}$$

可以将每个3-CNF可满足性问题的实例，多项式时间归约成 团问题的某个特殊实例，即 $\text{3-CNF-SAT }\le_P \text{CLIQUE}$。

具体过程略。这里主要注意在归约过程中，可以将已知NP完全问题的所有实例转成待验证问题的特殊实例，这样足够证明待验证问题是具有 NP 难度的。因为如果有一个多项式时间的算法可以解决待验证问题的一般实例，则也能解决其特殊实例。
但是不能将已知NP完全问题的特殊实例转成待验证问题的实例。因为某些NP完全问题的特殊实例是有多项时间算法可解的。

### 顶点覆盖问题
无向图$G = (V, E)$ 的**顶点覆盖（vertex cover）**是指子集 $V' \subseteq V$，满足如果 $(u, v) \in E$，则$u \in V'$ 或 $v \in V'$ （或两者成立）。亦即，每个顶点“覆盖”与其关联的边。 $G$ 的顶点覆盖是覆盖 $E$ 中所有边的顶点组成的集合。顶点覆盖的规模是指它所包含的顶点数目。
**顶点覆盖问题（vertex cover problem）**是指在给定的图中，找出具有最小规模的顶点覆盖。是最优化问题。其判定问题可以表述为：确定一个图是否具有一个给定规模为 $k$ 的顶点覆盖。形式语言定义为：
$$ \text{VERTEX-COVER} = \{ \langle G, k \rangle: G 具有规模为 k 的顶点覆盖\}$$

**顶点覆盖问题是NP完全问题**。
可以将每个团问题的实例，归约成顶点覆盖问题，即 $ \text{CLIQUE}\le_P\text{VERTEX-COVER}$。

对于无向图 $G = (V, E)$，定义补图 $\bar{G} = (V, \bar{E})$，其中 $\bar{E} = \{(u, v): u, v \in V, u \neq v, (u, v) \notin E\}$。
可以证明图 $G$ 具有一个规模为$k$ 的团，当且仅当图$\bar{G}$ 有一个规模为 $|V| -k$ 的顶点覆盖。

### 哈密顿回路问题
无向图 $G = (V, E)$ 中的一个哈密顿回路是通过 $V$ 的每个顶点一次的简单回路。
具有这种回路的图称为**哈密顿图**，否则称为**非哈密顿图**。

哈密顿回路问题：“图$G$ 是否具有一条哈密顿回路？”，其形式语言定义为：
$$ \text{HAM-CYCLE} = \{ \langle G \rangle: G是一个哈密顿图 \}$$

**哈密顿回路问题是NP完全问题**
可以证明 $\text{VERTEX-COVER} \le_P \text{HAM-CYCLE}$ 。 给定一个无向图 $G=(V,E)$和一个整数$k$ ，构造一个无向图 $G' = (V', E')$，使得它包含一个哈密顿回路，当且仅当$G$ 中有一个大小为 $k$ 的顶点覆盖。

具体构造比较巧妙。可以参考原书。此处略。

### 旅行商问题
旅行商问题（traveling-salesman problem）与哈密顿问题密切相关： 在该问题中，一个旅行商访问图中的每个点一次，然后回到原点。如果从$u$ 到$v$ 的访问代价为 $c(u, v)$，旅行商希望整体的访问费用最低。形式语言定义为：
$$ \text{TSP} = \{ \langle G, c, k \rangle: G = (V, E) 是一个完全图，c 是 V \times V \to \mathbf{Z} 上的一个函数， k \in \mathbf{Z} 且 G 包含一个费用至多为k 的旅行商的旅行回路 \}$$

** 旅行商问题是NP完全问题**
可以将任意哈密顿回路问题的实例转换成旅行商问题的实例，定义费用函数$c$ 为：
$$ c(i,j) = \left \{  \begin{array} {l} 0 & \text{if} \ (i,j) \in E \\ 1 & \text{if} \ (i,j) \notin E \end{array} \right . $$ 则图 $G$ 中具有一条哈密顿回路，当且仅当图 $G'$ 中具有一条费用至多为0的旅行回路。

### 子集和问题
子集和问题（subset-sum problem）是一个算术问题，其形式语言定义为：
$$ \text{SUBSET-SUM} = \left\{ \langle S, t \rangle : 存在一个子集 S' \subseteq S, 满足 t = \sum_{s \in S'}s\right\} $$

**子集和问题是NP完全的**
可以证明： $\text{3-CNF-SAT} \le_P \text{SUBSET-SUM}$。
可以通过将任一个 3-CNF公式 $\phi$ 转换成一个子集和的实例$\langle S, t \rangle$：该3-CNF公式是可满足的，当且仅当 $S$具有一个子集，其和恰为 $t$。
