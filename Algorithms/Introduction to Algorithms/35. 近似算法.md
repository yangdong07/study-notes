


主要内容：
- 最优化问题的近似算法
- 近似比（与最优解的偏差度量）
- 多项式时间近似方案
- 完全多项式时间的近似方案


## 近似算法概念
如果对规模为 $n$ 的任何输入，由近似算法产生的解的代价$C$ 与最优解的代价 $C^*$ 只差一个因子 $\rho(n)$：$$ \max{\left( \frac{C}{C^*}, \frac{C^*}{C} \right)}  \le \rho(n) $$ 则称该近似算法具有**近似比（approximation ratio）** $\rho(n)$。这个公式对求最大值问题和最小问题都适用。并且近似比 $ \rho(n)$ 一定是不小于1的。
如果$\rho$ 与$n$ 无关，则称为 $\rho$ 近似算法。
1近似算法产生的是最优解。

一些NP完全问题允许有多项式时间的近似算法，通过消耗越来越多的计算时间，这些近似算法可以达到不断缩小的近似比。

一个最优化问题的**近似方案（approximation scheme）**是这样的一种近似算法，它的输入除了该问题的实例外，还有一个值$\epsilon > 0$，使得对任何固定的 $\epsilon > 0$，该方案是个 $(1+\epsilon)$ 近似算法。

对一个近似方案来说，如果对任何固定的 $\epsilon > 0$，该方案都以其输入实例的规模 $n$ 的多项式时间运行，则称此方案为**多项式时间近似方案**。

_当$\epsilon$ 减少时，近似方案的运行时间会迅速增长_

对一个近似方案来说，如果其运行时间既为 $1/\epsilon$ 的多项式，又为输入实例的规模$n$ 的多项式，则称其为 **完全多项式时间的近似方案**。

## 顶点覆盖问题的近似算法

给定一个无向图 $G = (V, E)$
主要步骤：
1. 从 $E$ 中任意选出一条边$(u, v)$，把$u, v$ 加入到顶点集 $V'$，并从 $E$ 中，将$u, v$ 相关的其它边都移去。
2. 重复第一步操作，直到$E$ 为空集。

这样$V'$ 中包含了图 $G$ 的顶点覆盖。 这是一个近似算法，可以证明，这是一个2近似算法。即： $$ C \le 2 C^* $$

证明的思想：
1. 设算法选出的边的集合为 $A$，则 $A$ 中每条边都会被最优解 $C^*$ 覆盖，并且任两条边都不会被 $C^*$ 中同一点覆盖（根据$A$ 的选择规则），所以$C^* \ge |A|$
2. 又 $C = 2|A|$，所以$C \le 2C^*$

## 旅行商问题

给定一个完全无向图$G= (V, E)$，其中每条边$(u, v) \in E$ 都有一个非负的整数代价$c(u, v)$，希望找出$G$ 的一个具有最小代价的哈密顿回路。

在很多实际情况中，从一个地方$u$ 到另一个地方$w$ 的直接路径总是代价最小的。经过某个中转 $v$ 则会增加代价（两点之间直线最短）。形式化表示就是，如果对所有的顶点 $u, v, w \in V$，有：
$$ c(u, w) \le c(u, v) + c(v, w)$$ 则称代价函数 $c$ 满足**三角不等式**。


### 满足三角不等式的旅行商问题的 2近似算法

主要步骤：
1. 利用 $c(u,v)$ 作为权值，计算一个最小生成树 $T$
2. 从最小生成树$T$ 构造一条遍历路线（前序访问遍历）。

可以证明，该近似算法是一个多项式时间的2近似算法。

证明思路：
1. 设 $H^*$ 表示在给定顶点集合上的一个最优游程（回路），删除任意一条边，可以得到一棵生成树。因此对于最小生成树 $T$，其权值为最优游程代价的一个下界，即 $c(T) \le c(H^*)$
2. 对$T$ 的**完全（中序）遍历**经过每个点两次，称这个遍历为$W$，则 $c(W) = 2c(T)$
3. 在 $W$ 中去掉任意一次重复访问，代价不会增加（三角不等式）
4. 综上，有 $c(H) \le c(W) = 2c(T) \le 2c(H^*)$


### 一般旅行商问题
**如果 $P \neq NP$ 则对任何常数 $\rho \ge 1$，一般旅行商问题不存在具有近似比 $\rho$ 的多项式时间近似算法**

证明思想：
设 $G = (V, E)$ 为哈密顿回路问题的一个实例，设 $G' = (V, E')$ 为 $V$ 上的完全图，构造一个旅行问题的实例，其中 $$ c(u, v) = \left\{
\begin{array} {l}
1 & \text{if} \ (u, v) \in E \\
\rho|V| + 1 & \text{else}
\end{array} \right . $$

如果$G = (V, E)$ 有一个哈密顿回路，则其在旅行问题 $(G', c)$ 中的代价为 $|V|$。如果 $G$ 中没有哈密顿回路，则在旅行问题 $(G', c)$ 的任意游程中必用到不在 $E$ 的一条边，这样的游程的代价至少为 $(\rho|V| + 1) + (|V| - 1) = \rho|V| + |V| > \rho|V|$

所以，如果旅行商问题存在近似比为 $\rho$ 的多项式时间近似算法$A$，则得到的解的代价一定在 不大于$\rho|V|$。如果$G$ 包含一个哈密顿回路，则$A$ 必定返回这个回路。否则 $A$ 就会返回一个代价大于 $\rho|V|$ 的游程。矛盾。

### 集合覆盖问题
集合覆盖问题的一个实例$(X, \mathcal{F})$由一个有穷集合 $X$ 和一个 $X$ 的子集族 $\mathcal{F}$ 构成，且 $X$ 的每一个元素属于 $\mathcal{F}$ 中的至少一个子集： $$ X = \bigcup_{S \in \mathcal{F}}{S}$$ 我们说一个子集 $S \in \mathcal{F}$ 覆盖了它的元素。
集合覆盖问题是要找出一个最小规模子集 $\mathcal{C} \subseteq \mathcal{F}$，使其所有成员覆盖 $X$ 的所有成员。

#### 一个贪心近似算法
贪心方法在每一阶段都选择出能覆盖最多的、未被覆盖的元素的集合 $S$。
主要步骤：
1. 初始化 $\mathcal{C}$ 为空集，$U = X$
2. 从 $\mathcal{F}$ 中找出一个集合 $S$， 使得 $|S \cap U|$ 最大（覆盖最多元素），然后将$S$ 中所有元素从$U$ 中移除：$U = U - S$。将 $S$ 加入 $\mathcal{C}$
3. 重复第2步，直到 $U = \emptyset$

可以证明： 该算法是一个 多项式时间的 $\rho(n)$ 近似算法，其中 $$ \rho(n) = H(\max\{|S|: S \in \mathcal{F} \}) \\ H(d) = \sum_{i=1}^d{1/i} $$
根据调和级数的界，可以知道 算法是一个多项式时间的 $\ln{|x|} + 1$ 近似算法

### MAX-3-CNF问题的随机化近似算法
随机化近似算法的近似比是一个期望值。

MAX-3-CNF问题： 对于一个3-CNF公式，希望找出一种赋值，使得有尽可能多的子句得到满足。

** 给定MAX-3-CNF问题的一个实例，它有 $n$ 个变量 $x_1, x_2, \cdots, x_n$ 和 $m$ 个子句，以概率 $1/2$ 独立地将每个变量置为1和以概率为 $1/2$独立地将每个变量设置为0的随机化近似算法是一个随机化的$8/7$ 近似算法。**


### 最小权值顶点覆盖问题的 线性规划近似算法
**最小权值顶点覆盖问题**（minimum-weight vertex-cover problem）中，给定一个无向图 $G = (V, E)$，以及每个顶点的正的权值 $w(v), v \in V$。对任意顶点覆盖 $V'\subseteq V$，定义该顶点覆盖的权 为 $w(V') = \sum_{v \in V'}{w(v)}$。目标是找出一个具有最小权值的顶点覆盖。

近似算法思想：利用线性规划找出权值的一个下届。然后对计算出来的结果进行“舍入”，并得到一个顶点覆盖。

对每个顶点$v \in V$，定义一个变量 $x_v$，并且，对每一个顶点 $v \in V$， $x_v \in [0, 1]$
将 $x_v = 1$ 表示 $v$ 在顶点覆盖， $x_v = 0$ 表示 $v$ 不在顶点覆盖，那么对于任意边 $u, v$，至少有一个点必须在顶点覆盖中，即 $x_u + x_v \ge 1$。
因此，就有用于寻找最小权值顶点覆盖的 **0-1整数规划（0-1 integer program）**：
最小化 $$ \sum_{v\in V}{w(v)x_v}$$
约束有 $$ x_u + x_v \ge 1 \quad \text{for } (u, v) \in E \\ x_v \in [0, 1] \quad \text{for } v \in V $$

对这样的线性规划问题，计算出解后。对每个 $x_v$，如果小于 $1/2$，则不将 $v$ 放入顶点覆盖；否则将 $v$ 加入顶点覆盖。

可以证明：
1. 根据舍入原则收集的顶点，构成一个顶点覆盖。
2. 该算法是一个多项式时间的2近似算法。

第一点，因为对每条边 $(u, v) \in E$， 线性规划的计算结果满足约束条件 $\bar{x}_u + \bar{x}_v \ge 1$，因此 $\bar{x}_u$ 和$\bar{x}_v$ 至少有一个不小于$1/2$，因此至少有一个点被收集到。所以最终的收集的集合必覆盖了每一条边，构成一个顶点覆盖。

### 子集和问题

#### 一个指数时间的准确算法

子集和问题的一个实例为 $(S, t)$，即从 $S$ 中找出和为 $t$ 的元素子集。元素均为正整数。
相关最优化问题： 希望找出 $\{x_1, x_2, \cdots, x_n\}$ 的一个子集，使其中元素相加之和尽可能地大，但不能大于 $t$。

主要思想：
设输入集合为 $\{x_1, x_2,\cdots, x_n\}$
定义 $S + x = \{ s + x: s \in S \}$
从 $L_0 = \{0\}$ 开始迭代计算 $L_i = L_{i-1} \cup (L_{i-1} + x_i) $。
在第$i$ 轮迭代中，计算 $\{x_1, x_2, \cdots, x_i\}$ 的所有子集的元素和，是从 $\{x_1, x_2, \cdots, x_{i-1}\}$ 的所有子集的和 与 $x_i$ 得到。
如果$L$ 中有元素超过目标值 $t$，则可以移去（减少运算量）

这种方法的运行时间是与输入规模$n$ 成指数关系。

#### 一个完全多项式时间的近似方案

在每个$L_i$ 创建之后，可以对它进行“修整”，以减少运算量。

具体思想是，如果$L$ 中两个值比较接近，那么，出于寻找近似解的目的，没有必要同时保存这两个数。

定义一个修整参数 $\delta$，满足 $ 0 < \delta < 1$，对于 $L$ 中两个数 $z, y$，如果满足： $$ z \le y \le z(1+\delta)$$ 则保留$z$，移去 $y$ ，或者说用 $z$ 代表$y$。上式还可以写成：$$ \frac{y}{1+\delta} \le z \le y $$ 但是意思不是很明显。

将 $L$ 第一个元素加入 $L'$，然后按递增顺序将$L$ 中的每个元素 $y$ 与 $L'$ 的最后一个元素 $z$ 比较。如果 $y > z(1+\delta)$，则把$y$ 加入到 $L'$。否则，用 $z$ 代表$y$ 即可。

给定一个输入集合$S$，一个目标整数$t$，以及一个“近似参数” $\epsilon$。令修整参数 $\delta = \epsilon / 2n$，则每次对$L$修整，得到的最后结果为$z$，该值落在最优解的 $1 + \epsilon$ 倍内。

并且，使用修整后$L_i$ 的大小是 $n/\epsilon$ 的一个多项式。算法的运行时间是 $1/\epsilon$ 的多项式。该近似方案是一个完全多项式时间的近似方案。
