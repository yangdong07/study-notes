

**动态规划 dynamic programming**
也是通过组合子问题的解而解决整个问题。

动态规划通常应用于最优化问题。此类问题可能有许多可行解，每个解有个值（度量），希望找到一个具有最优（最大或最小）值得解，为最优解。

动态规划算法的设计可以分为如下4个步骤：
1. 描述最优解的结构（如何通过分解成子问题，并选择）
2. 递归定义最优解的值（即子问题组合，及选择求值）
3. 按自底向上的方式计算出最优解的值
4. 由计算出的结果构造一个最优解

## 装配线调度问题
### 问题
有两条汽车装配线，每个装配线都有 $n$ 个装配站，用于完成相应的工序。将装配线 $i$ 的第 $j$ 个装配站表示为 $S_{i,j}$。由于建造时间和技术不同，每个装配站所需的时间不同（记为$a_{i,j}$）。
正常情况下，底盘进入一条转配线后，延该装配线装配部件，完成生产。
特殊情况下，底盘可能要在装配线之间切换，使总体装配时间最短。注意切换装配线是需要时间的。任何从 $S_{i,j}$切换到另一条线上下一个装配站的时间为 $t_{i,j}$，在同装配线里转移到下一个装配站的时间可以忽略。
底盘进入装配线 $i$ 的进入时间为 $e_i$，装配完的汽车离开装配线$i$ 的离开时间为 $x_i$

问题是，如何选择两条线上的装配站，使得总体装配时间最短。

### 最优解的结构
两条装配线， $i =1, 2$
到达装配站 $S_{1, j}$的最优路径，一定是从 到达 $S_{1, j-1}$的最优路径 或 $S_{2, j-1}$的最优路径中选择。

这样每个问题分解成两个子问题。且这些子问题总共只有 $\Theta(n)$个

### 递归定义最优解的值
令 $f_i[j]$ 表示一个底盘从起点到装配站 $S_{i,j}$的最快可能时间
定义 $f^{*}$ 为底盘通过工厂的所有路线的最快时间。则有：
$$
f^{*} = \min(f_1[n] + x_1, f_2[n] + x_2)\\
f_1[1] = e_1 + a_{1, 1}\\
f_2[1] = e_2 + a_{2, 1}\\
f_1[j] = \left\{
\begin{array}{l}
e_1 + a_{1, 1}  & if \ j = 1 \\
\min{(f_1[j-1] + a_{1,j}, \  f_2[j-1] + t_{2, j-1} + a_{1, j})} & if \ j \ge 2\\
\end{array} \right. \\
f_2[j] = \left\{
\begin{array}{l}
e_2 + a_{2, 1}  & if \ j = 1 \\
\min{(f_2[j-1] + a_{2,j}, \  f_1[j-1] + t_{1, j-1} + a_{2, j})} & if \ j \ge 2\\
\end{array} \right.
$$

### 自底向上的方式计算
从 $f_1[1]$ 和 $f_2[1]$开始可以求出所有的 $f_i[j]$ 值，以及最后的 $f^{*}$。

### 构造最优解
在计算过程中，定义 $l_i[j]$ 为计算到达装配站 $S_{i, j}$的最短时间 $f_i[j]$ 时，选择的前一个装配站的 $i$ 值（1或2），这样可以通过 $l_i[j]$ 构造一个最优解

### 递归 + 备忘录（memoize） 计算
如果用正常的递归形式求解，运行时间为 $\Theta(2^n)$，虽然全部子问题只有 $\Theta(n)$ 个。
这是因为在递归中重复计算了相同的子问题（子问题发生了重叠）。如果把相同子问题的结果存入一张表中，则可以避免重复计算，使得递归方法可以在 $\Theta(n)$时间内完成。
然而，递归方式还是不如直接自底向上计算快，因为多了递归的代价。


## 矩阵链乘法

### 问题定义
对一个矩阵链做乘法： $A_1A_2 \cdots A_n$
** fully parenthesized **递归定义：称一组矩阵的乘积是 fully parenthesized，如果它是单个矩阵，或是两个 fully parenthesized 矩阵的乘积外加括号。

仅当两个矩阵A和B相容（即A的列数等于B的行数）时，才可以进行相乘运算，设 $A$ 为 $p \times q $ 矩阵， $B$ 为 $q \times r $ 矩阵，则乘法运行次数为 $pqr$

**矩阵链乘法问题**：给定 $n$ 个矩阵构成的一个链$\langle A_1, A_2, \cdots, A_n \rangle$，其中矩阵 $A_i$ 为 $p_{i-1} \times p_i$ 矩阵，对乘积 $A_1A_2 \cdots A_n$ 以一种最小化标量乘法次数的方式进行“fully parenthesized”

以正常思路，遍历所有的加括号方式，需要 $\Omega(2^n)$时间

### 最优解的结构
不失一般性，对一个 $A_iA_{i+1} \cdots A_j$ 问题的求解，一定会分解成 $A_i\cdots A_k$ 和 $A_{k+1}\cdots A_j$ 两个问题，其中 $i \le k \le j$

而问题 $A_iA_{i+1} \cdots A_j$ 的最优解一定蕴含着子问题 $A_i\cdots A_k$ 和 $A_{k+1}\cdots A_j$ 的解也是最优的。否则用最优的子问题的解替换，就可以得到一个更好的解，是矛盾的。

所以，对 $A_iA_{i+1} \cdots A_j$ 问题的最优解，一定是从 $j-i-1$ 对子问题（$k$ 的位置不同）的最优解中选择出来的。

全部子问题的数量为 $\Theta(n^2)$ （因为 $A_{i..j}$是一个子问题，且 $ 1\le i \le j \le n$）

### 递归定义最优解的值
令 $m[i,j]$ 为 $A_iA_{i+1} \cdots A_j$ 的乘法的最小次数，即最优解
$$m[i, j] = \left\{
\begin{array}{l}
0  & if \ i = j \\
\min_{i\le k < j}{(m[i, k] + m[k+1, j] + p_{i-1}p_kp_j)} & if \ i < j \\
\end{array} \right.
$$

### 构造最优解
在每次计算 $m[i,j]$时，记下选择的 $k$ 值，记到 $s[i, j]$ 中。
这样，就可以反向构造出分割加括号的地方。

算法运行时间为 $O(n^3)$


## 动态规划基础
** 最优子结构 ** 和 ** 重叠子问题 **

### 最优子结构

如果问题的一个最优解包含了子问题的最优解，则该问题具有最优子结构。

最寻找最优子结构时，可以遵循一些共同的模式
1. 问题的一个解可以是（在可分解为的子问题中）做一个选择
2. 假设给定一个问题，已知的是一个可以导致最优解的选择。不必关心如何确定这个选择。
3. 在已知这个选择后，要确定哪些子问题会随之发生，以及如何最好地描述所得到的子问题空间。
4. 利用 “cut-and-paste”技术，来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的。通过假设每一个子问题的解都不是最优解，然后导出矛盾，即可做到这一点。特别地，通过“cut”非最优的子问题再“paste”最优解，就证明了可以得到原问题的一个更好的解，这与假设已经得到了一个最优解相矛盾。

非正式的，一个动态规划算法的运行时间依赖于两个因素的乘积：
- 子问题的总个数
- 每一个子问题中有多少种选择

例如：装配线问题中，子问题的总个数为 $\Theta(n)$，选择只有2次，因此执行时间为 $\Theta(n)$。
矩阵链乘法问题中， 子问题的总个数为 $\Theta(n^2)$，每个子问题中至多 $n-1$次选择（实际上是 $j-i-1 \le n - 1$）次选择，因此执行时间是 $O(n^3)$


_注意一点： 子问题必须是**独立**的。意思是：在选择的子问题中，其使用的资源必须是相互独立的，否则构不成最优子结构。
例如在 最长简单路径问题中，分解的子问题共享了相同的资源。
这一点可以多体会。_

### 重叠子问题
子问题的空间要“小”，是输入规模的一个多项式，例如$\Theta(n^a)$


## 最长公共子序列问题

**子序列定义** ： 给定一个序列 $X = \langle x_1, x_2, \cdots, x_m \rangle $，另一个序列 $Z = \langle z_1, z_2, \cdots, c_k \rangle$ 是 $X$的一个子序列，如果存在 $X$ 的一个严格递增下标序列 $\langle i_1, i_2, \cdots, i_k \rangle$，使得对所有的 $j = 1, 2, \cdots, k$，有 $x_{i_j} = z_j$。

**公共子序列** ： 给定两个序列 $X$ 和$Y$，称序列 $Z$ 是 $X$ 和 $Y$的公共子序列，如果 $Z$ 既是 $X$ 的一个子序列，又是 $Y$ 的一个子序列。

**最长公共子序列（Longest-Common-Subsequence, LCS）**问题：给定两个序列 $X = \langle x_1, x_2, \cdots, x_m \rangle $，$Y = \langle y_1, y_2, \cdots, y_n \rangle $，希望找出 $X$ 和 $Y$ 的最长公共子序列。

**序列前缀**： 给定一个序列 $X = \langle x_1, x_2, \cdots, x_m \rangle $， $X$的第 $i$ 个前缀为 $X_i = \langle x_1, x_2, \cdots, x_i \rangle $

### LCS的最优子结构
设 $X = \langle x_1, x_2, \cdots, x_m \rangle $，$Y = \langle y_1, y_2, \cdots, y_n \rangle $ 为两个序列， 并设 $Z = \langle z_1, z_2, \cdots, z_k \rangle$ 是$X$ 和 $Y$ 的任意一个 LCS
1. 如果 $x_m = y_n$，那么 $z_k = x_m = y_n$，并且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个LCS
2. 如果 $x_m \neq y_n$，那么 $z_k \neq x_m $ 蕴含着 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个LCS
3. 如果 $x_m \neq y_n$，那么 $z_k \neq y_n $ 蕴含着 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个LCS

### LCS的一个递归解
令 $c[i,j]$ 为序列 $X_i$ 和$Y_j$ 的一个LCS的长度，则有递归式：
$$c[i, j] = \left\{
\begin{array}{l}
0  & if \ i = 0 \ or \ j = 0 \\
c[i-1, j-1] + 1 & if \ i , j > 0 \ and \ x_i = y_j \\
\max{(c[i, j-1], c[i-1,j])} & if \ i, j > 0 \ and \ x_i \neq y_j \\
\end{array} \right.
$$


## 最优二叉查找树

给定一个由 $n$ 个互异的关键字组成的序列 $K = \langle k_1, k_2, \cdots, k_n \rangle$，且关键字有序（因此有 $k_1 < k_2 < \cdots < k_n$ )。对每个关键字 $k_i$，一次搜索为 $k_i$ 的概率为 $p_i$。某些搜索的值可能不在 $K$ 内，因此有 $n+1$个“虚拟键” $d_0, d_1, d_2, \cdots, d_n$ 代表不在 $K$ 内的值。具体地， $d_0$ 表示所有小于 $k_1$ 的值， $d_n$ 表示所有大于 $k_n$ 的值， $d_i$ 代表所有位于 $k_i$ 和 $k_{i+1}$ 之间的值。一次搜索对应于 $d_i$ 的概率为 $q_i$。 $$ \sum_{i=1}^n{p_i} + \sum_{i=0}^n{q_i} = 1$$

期望从这些关键字构造一棵二叉查找树，使得搜索代价的期望最小。这种树称为 **最优二叉查找树**

定义搜索的代价是：搜索深度的期望值 加上1。

### 最优二叉查找树的结构

一棵二叉查找树的任意一棵子树必定包含在连续范围内的关键字 $k_i, \cdots, k_j$，对某个 $1\le i \le j \le n$。另外，这样的子树必定含有 $d_{i-1}, \cdots, d_j$ 作为叶子。

最优子结构： 如果一棵最优二叉查找树$T$ 有一棵包含关键字 $k_i, \cdots, k_j$的子树 $T'$，那么这颗子树 $T'$ 对于关键字 $k_i, \cdots, k_j$ 和虚拟键  $d_{i-1}, \cdots, d_j$  的子问题必定是最优的。

给定一棵树 $T$ 包含关键字 $k_i, \cdots, k_j$，可以选择 $k_r, i\le r \le j$ 作为根，用 $k_i, \cdots, k_{r-1}$ 和 $k_{r+1}, \cdots, k_j$ 作为子树。
这里子问题是 $T': k_i, \cdots, k_{r-1}$ 和 $T'':  k_{r+1}, \cdots, k_j$ 两棵子树， $T$ 是最优的，蕴含着 $T'$ 和 $T''$ 也是最优的。所以可以从 $j - i$ 对子树中 选择一种构造最优解

### 递归解的形式
定义： $e[i,j]$ 为搜索一棵包含关键字 $k_i, \cdots, k_j$ 的最优二叉查找树 $T$ 的期望代价。
定义： $w[i,j]$ 为 $T$ 上所有结点（包括虚拟键）的概率总和：
$$ w(i,j) = \sum_{l=i}^j{p_l} + \sum_{l=i-1}^j{q_l}$$
注意用这个式子主要是为了方便将子树深度加1（实际上就是期望值再加上 $w(i,j)$）

递归式：
$$e[i, j] = \left\{
\begin{array}{l}
q_{i-1}  & if \ j = i-1 \\
\min_{i\le r \le j}{(e[i, r-1] + e[r+1, j] + w(i,j))} & if \ i \le j \\
\end{array} \right.
$$

运行时间与 矩阵链乘法差不多，都是 $O(n^3)$。
