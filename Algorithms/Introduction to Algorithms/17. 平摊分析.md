

## 平摊分析 ： amortized analysis
对一个数据结构一系列的操作 的**平摊分析** 是 分析 这些操作所用的平均时间。
与平均情况分析（期望）使用概率分析不同，平摊分析保证在最坏情况下，每个操作具有平均性质。

### 聚集分析
在聚集分析（aggregate analysis）中，要证明对所有的 $n$ ，由 $n$ 个操作所构成的序列的总时间在最坏情况下为 $T(n)$，每个操作的平均代价（或称**平摊代价**，amortized cost)为 $T(n)/n$。
注意这个平摊代价对每个操作都是成立的，与操作类型无关。

### 记账方法
在平摊分析的记账方法里，对每个操作收取不同的费用（平摊代价），平摊代价 与 实际代价 相比 或多或少。
当一个平摊代价超过了其实际代价时，多收的部分称为 **存款（credit）**，并赋予数据结构中的特定对象中（以备补偿其他操作）。 存款可以用于补偿那些 平摊代价小于实际代价的操作。
设第 $i$ 个操作的实际代价为 $c_i$，平摊代价为 $\hat{c}_i$，对 $n$ 个操作的所有序列须满足：$$ \sum_{i=1}^{n}{\hat{c}_i} \ge  \sum_{i=1}^{n}{c_i}$$。数据结构中的总存款为总的平摊代价和总的实际代价之差： $ \sum_{i=1}^{n}{\hat{c}_i} -  \sum_{i=1}^{n}{c_i}$ ，总存款必须始终是非负的，这样总的平摊代价就是总的实际代价的一个上界。

### 势能方法
势能方法（potential method），势函数将 $\Phi$ 将每个数据结构 $D_i$ 映射为一个实数 $\Phi(D_i)$。第 $i$ 个操作的平摊代价定义为 $$ \hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1}) $$，即实际代价加上增加的势能。
$n$ 个操作的总的平摊代价为：$$  \sum_{i=1}^{n}{\hat{c}_i} = \sum_{i=1}^{n}{\left( c_i + \Phi(D_i) - \Phi(D_{i-1}) \right)} = \sum_{i=1}^{n}{c_i} + \Phi(D_n) - \Phi(D_0)$$

与记账方法类似，如果对所有 $D_i$ ，有 $\Phi(D_i) \ge \Phi(D_0)$，就可以得到 总的实际代价的一个上界。在设计势函数时，可以令 $\Phi(D_0) = 0$。

## 栈结构
操作有 PUSH、POP、MULTIPOP（一次弹出多个）
实际代价：
- PUSH: 1
- POP: 1
- MULTIPOP:  $\min(s, k)$，其中 $s$ 是栈中的对象个数， $k$是参数，表示弹出几个$

对任意 $n$ 个操作的平摊分析可以得出总的运行时间为 $O(n)$，每个操作的平摊时间为 $O(1)$。
### 记账方法
令平摊代价为：
- PUSH: 2
- POP: 0
- MULTIPOP: 0

每次PUSH操作，除了支付其实际代价 1 以外，还预支了将其 POP 的代价 1（存款），将存款放在PUSH的对象上。当这个对象被 POP 的时候，无论是POP还是MULTIPOP，可以使用存款支付，而无需使用其他费用（所以平摊代价为0）。
这样，任意 $n$ 个操作的 总的平摊时间 为 $O(n)$

### 势能方法
定义势能函数 $\Phi$ 为栈中对象的个数。则有 $$ \Phi(D_i) \ge 0 = \Phi(D_0) $$。则可以计算各个操作的平摊代价：
- PUSH： $\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1}) = c_i + 1 = 2$
- POP： $\hat{c}_i = c_i - 1 = 0$
- MULTIPOP: 弹出 $k'$个，势函数减少 $k'$ ，所以 $\hat{c}_i = k' - k' = 0$

所以总的平摊时间为 $O(n)$，总的运行时间 $T(n) = O(n)$ ，每个操作的平摊时间为 $O(1)$。


## 二进制计数器递增1
$k$ 位二进制计数器。
每次操作都可能产生进位：将某几位置0，最高进位置1。或者最高位溢出。
对 $n$ 次递增操作的总的平摊代价为 $O(n)$，为实际运行时间的上界。

### 记账方法
- 对每个置1操作，支付 2元，其中1元为实际代价，另1元放在1上，作为存款，用于支付置0 的操作。
- 对每个置0操作，由于1上有存款，所以无需费用，平摊代价为0。

每次递增最多只有一位置1，所以总的平摊代价为 $O(n)$。

### 势能方法
定义势函数 $\Phi$ 为 计数器上 1 的个数。则有 $$ \Phi(D_i) \ge 0 = \Phi(D_0)$$ 每次操作最多将1位数字置1，并假设第 $i$ 次操作对 $t_i$ 个位进行了复位（置0）操作，如果 $b_i = 0$，则第 $i$ 次操作没有置1，所以 $b_{i-1} = t_i = k$。如果 $b_i > 0$，则 $b_i = b_{i-1} - t_i + 1$，两种情况都有： $b_i \le b_{i-1} - t_i + 1$， $$ \Phi(D_i) - \Phi(D_{i-1}) \le - t_i + 1 $$ 每次平摊代价：
$$ \hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1}) \le t_i + 1 + 1 - t_i = 2 $$
总的实际代价：
$$  \sum_{i=1}^{n}{c_i} = \sum_{i=1}^{n}{\hat{c}_i}  - \Phi(D_n) + \Phi(D_0) \le 2n - b_n + b_0 \le 2n + k$$
只要 $k = O(n)$，总的实际代价就是 $O(n)$


## 动态表
指在插入元素和删除元素可以动态扩充或缩小容量的数组或table。

注意这里插入元素如果没有超过数组容量，则直接插入，实际代价为1。如果超过了数组容量，则需要将容量扩充（另分配一个 $\times 2$ 空间存放），然后把之前的数挪过去，再插入，实际代价是 $num_i$ 。
删除元素同样。

只有插入操作时，总的平摊代价为 $O(n)$，每次操作平摊代价为 $O(1)$
插入和删除操作时，总的平摊代价也是 $O(n)$

分析过程略。
