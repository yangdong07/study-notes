


1. 图的表示
2. 广度优先搜索 BFS
3. 深度优先搜索 DFS
4. 拓扑排序：DFS应用
5. 强连通分支：DFS应用

搜索一个图是有序的沿图的边访问所有顶点。图的搜索算法可以使我们发现图的很多结构信息。

## 图的表示
要表示一个图 $G = (V, E)$，有两种标准的方法：
- 邻接表
- 邻接矩阵

### 邻接表
由一个包含 $|V|$ 个 list 的数组 $Adj$ 表示，每个list 对应于 $V$ 中的一个顶点。$Adj[u]$ 包含所有满足条件 $(u,v) \in E$ 的顶点。

邻接表的储存空间为 $\Theta(V + E)$

### 邻接矩阵
设顶点按任意方式编号为 $1, 2, \cdots, |V|$，那么 $G$ 的邻接矩阵为一个 $|V| \times |V|$ 的矩阵  $A=(a_{ij})$，满足：$$ a_{ij} = \left\{
\begin{array}{l} 1 \quad if \ (i, j) \in E \\ 0 \quad else \\ \end{array} \right. $$

邻接矩阵的储存空间为 $\Theta(V^2)$
如果仅用1、0，可以只用一个二进位表示一条边。

### 权值
如果对边，有加权函数 $w: E \to R$，也可以存储在邻接表或邻接矩阵中。


## 广度优先搜索 breadth-first search
图的搜索算法之一，基本算法之一。
主要思想：从起点 $s$ 开始，遍历从 $s$ 可以达到的所有顶点（广度遍历）。然后对这些顶点重复 $s$ 的动作。
1. 为了区分已访问的点和未访问的点，要做上标记。另外，对那些刚访问到的点，先放到队列中，以便进行下一轮遍历。实际上，每个顶点有三种状态：没有被访问、刚访问到放入队列、已访问且已经对其所能达到的未访问的点进行了一次遍历（移出队列）。在书上用 “白色”、“灰色”、“黑色”表示。在实际应用中，在队列中就表示是灰色状态，无需标记。
2. 如果从 $u$ 搜索到 $v$，且$v$ 尚未访问过（白色），则记录 $d[v] = d[u] + 1$，表示距离加1。令 $\pi[v] = u$，表示 $u$ 先于 $v$ 被访问，且 $v$ 是从 $u$ 搜索到的。特别地有， $d[s]= 0, \pi[s] = NIL$


### 先辈、父母、祖先、后裔
如果从 $u$ 能访问到 $v$ ，则称 $u$ 是 $v$ 的祖先， $v$ 是 $u$ 的后裔。

### 分析
根据算法，每个点至多被访问到一次，入队和出队时间为 $O(1)$，则队列操作全部时间为 $O(V)$。每个顶点出队时，才扫描邻接表，总的操作时间有 $O(E)$；初始化开销 $O(V)$，所以BFS的总运行时间为 $O(V + E)$

### 最短路径
对于一个图 $G = (V, E)$，定义 最短路径距离 $\delta(u, v)$ 为从 $u$到$v$ 的任何路径中最少的边数；如果 $u$ 和 $v$ 之间没有通路，则 $\delta(u, v) = \infty$。具有这一距离 $\delta(u, v)$ 的路径为从 $u$ 到 $v$ 的最短路径。

可以证明：BFS可以发现源顶点 $s$ 所能达到的所有顶点。且运行结束时，对所有 $v\in V$，有 $d[v] = \delta(s, v)$。且对任意从 $s$ 可达的顶点 $v \neq s$，从 $s$ 到 $v$ 的最短路径之一是从 $s$ 到 $\pi[v]$ 的最短路径加上边 $(\pi[v], v)$

### 广度优先树

前驱子图 predecessor subgraph $G_{\pi} = (V_{\pi}, E_{\pi})$，其中：
$$ V_{\pi} = \{ v \in V: \pi[v] \neq NIL \} \cup \{s\} \\
 E_{\pi} = \{ (\pi[v], v): v \in V_{\pi} \{s\}  $$

如果 $V_{\pi}$ 由 从$s$ 可达的顶点构成，则前驱子图是一棵广度优先树。BFS结束后，可以得到一棵广度优先树。

## 深度优先搜索 depth-first search
与广度优先搜索不同，深度优先搜索的搜索策略是尽可能“深”的搜索一个图。在DFS里，对于最新发现的顶点，如果还有以此为起点而未探测到的边，就沿此边继续探测下去。当顶点 $v$ 的所有边都已被探寻过后，搜索开始回溯发现$v$ 的点 $u$ 的其他未探寻的边。

先辈子图：$$ E_{\pi} = \{ (\pi[v], v): v \in V \ and\  \pi[v] \neq NIL \}$$

1. DFS可以从任意顶点开始执行，且最后产生的先辈子图是一个由数棵深度优先树所组成的深度优先森林。
2. 在DFS过程中，每个点同样有三种状态：未访问，刚访问到并继续深度搜索，已访问且完成所有的深度搜索（即所有边都探测过）。书中标记三种状态为白色、灰色、黑色。实际应用中，可以只标记访问过或未访问。灰色可以间接通过函数调用栈表示：访问过并正在深度搜索的点一定处于函数调用栈中。
3. 与BFS记录距离不同，DFS记录每个点开始访问和结束访问的时间戳。每访问一个点和离开一个点，时间戳+1。对每个点$u$， $d[u]$ 和 $f[u]$ 分别表示开始时间和结束时间， $d[u] < f[u]$， $u$ 在时刻 $d[u]$ 之前是白色的；在时刻 $d[u]$ 和 $f[u]$ 之间是灰色的，以后就变成黑色的了。

### 分析
对于邻接表：
对每个点只访问一次，对每个点的 $Adj[u]$ 也只扫描一遍，所以总运行时间为 $\Theta(V + E)$

### 深度优先搜索的性质

**括号定理： 对一个（有向或无向）图 $G =(V, E)$ 的任何深度优先搜索中，对图的任意两个顶点 $u$，$v$，下述三个条件中仅有一个成立：**
- 区间 $[d[u], f[u]]$ 和 区间 $[d[v], f[v]]$ 是完全不相交的，且在深度优先森林中， $u$ 和$v$ 都不是对方的后裔。
- 区间 $[d[u], f[u]]$ 完全包含于 区间 $[d[v], f[v]]$，且在深度优先树中， $u$ 是 $v$ 的后裔。
- 区间 $[d[v], f[v]]$ 完全包含于 区间 $[d[u], f[u]]$，且在深度优先树中， $v$ 是 $u$ 的后裔。

解释： $[d[u], f[u]]$ 完全包含 $[d[v], f[v]]$，也就是说在深度优先搜索中，先访问到 $u$，然后访问到 $v$，存在从 $u$ 到 $v$ 的路径， $v$ 是 $u$ 的后裔。

顶点 $v$ 是 $u$ 的后裔，当且仅当 $d[u] < d[v] < f[v] < f[u] $。

**白色路径定理： 在一个（有向或无向）图 $G =(V, E)$ 的深度优先森林中，顶点 $v$ 是顶点 $u$ 的后裔，当且仅当在搜索过程中于时刻$d[u]$ 发现 $u$ 时，可以从顶点 $u$ 出发，经过一条完全由白色顶点组成的路径到达 $v$。**

### 边的分类

根据在图 $G$ 上进行深度优先搜索所产生的深度优先森林 $G_{\pi}$ ，可以把图的边分为四种类型：
1. 树边（tree edge），是深度优先森林  $G_{\pi}$ 中的边。如果 顶点 $v$ 是在探寻边 $(u, v)$时被首次发现，则 $(u, v)$ 是一条树边
2. 反向边 （back edge），是深度优先树中，连接顶点 $u$ 到它的某一祖先顶点 $v$ 的非树边 $(u, v)$
3. 正向边（forward edge），深度优先树中，连接顶点 $u$ 到它的某个后裔 $v$ 的非树边 $(u, v)$
4. 交叉边 （cross edge），是其他类型的边，可以是同一棵深度优先树中的两个顶点之间，且这两个顶点都不是对方的祖先、后裔。也可以是连接不同树顶点的边。

对DFS算法对这些边进行分类，设从 $u$ 检查边 $(u, v)$：
1. 如果 $v$ 是白色，则$(u, v)$为树边
2. 如果 $v$ 是灰色，则$(u, v)$为反向边
3. 如果 $v$ 是黑色，且$d[u] < d[v]$ 则 $(u, v)$为正向边。（$d[u] < d[v]$，此时 $u$ 是灰色，但 $v$ 在 $u$ 之后访问，并且已经访问完了，所以 $v$ 一定是 $u$ 的后裔 ）
4. 如果 $v$ 是黑色，且$d[u] > d[v]$ 则 $(u, v)$为交叉边。 ($d[u] > d[v]$，表示 $v$ 先于 $u$ 被访问到，且也已经访问完了， $v$ 不是 $u$ 的祖先，也不是 $u$ 的后裔，存在于另一棵树或另一个树枝中，所以 $(u, v)$ 是交叉边。


**对一个无向图 $G$ 进行DFS时，$G$ 的每一条边要么是树边，要么是反向边。**


## 拓扑排序
**拓扑排序** 的定义： 对有向无回路图 $G=(V, E)$ 进行拓扑排序后，结果为该图所有顶点的一个线性序列，满足如果 $ (u, v) \in G$， 则在该序列中， $u$ 就出现在 $v$ 的前面。

一个图的拓扑排序可以看成图中所有顶点沿水平线排列，所有的有向边均从左指向右。

使用DFS对一个有向无回路图进行**拓扑排序**。
1. DFS(G)，并获得每个点的访问结束时间 $f[v]$
2. 在每个点结束时，插入到链表首部

运行时间： $\Theta(V + E)$

返回的链表即为拓扑排序的序列，是按照结束时间倒序排列的。可以证明，这样的序列为图 $G$ 的一个拓扑排序。


## 强连通分支
**强连通分支 strongly connected component** 的定义： 有向图 $G=(V, E)$ 的一个强连通分支就是一个最大的顶点集合 $C \subseteq V$，对于 $C$ 中的每一对顶点 $u$ 和 $v$，有 $u \leadsto v$ 和 $ v \leadsto u$，亦即：顶点 $u$ 和 $v$ 是互相可达的。

在寻找图 $G=(V, E)$ 的强连通分支的算法中，用到了 $G$ 的转置 $G^T = (V, E^T)$，$E^T = \{(u, v): (v, u) \in E\}$。 $G^T$ 是 $G$ 中所有边改变方向后变成的新图。

$G$ 和 $G^T$ 有着完全相同的强连通分支（注意是顶点集合）

寻找强连通分支的算法：
1. 在 $G$ 上做一次 DFS，并获得每个点的访问结束时间 $f[v]$
2. 在 $G^T$ 上做一次 DFS，初始点的使用顺序是按照 $f[v]$ 的倒序
3. 第二次DFS之后获得的 深度优先森林的每棵树的结点集合，都是图 $G$ 的一个强连通分支。

可以证明： 上述算法第二次DFS之后获得的深度优先森林中的每棵树，都构成图 $G$的一个强连通分支。

将发现和完成时间表示记号扩展到顶点集。如果 $U \subseteq V$， 则定义 $d(U) = \min_{u\in U}{\{d[u]\}}$， $f(U) = \max_{u\in U}{\{f[u]\}}$

证明要点：
1. 如果 $C$ 和 $C'$ 是两个不同的强连通分支，如果有一条边 $(u, v) \in E$，其中$u \in C, v \in C'$，则 $f(C) > f(C')$。这里 $f(C)$ 取自第一次 DFS 标记的 $f$ 值。
2. 如果有一条边 $(u, v) \in E^T$，其中$u \in C, v \in C'$，则 $f(C) < f(C')$。
3. 这样看，如果第二次从 $f$ 最大的点开始 进行的DFS，会得到一个强连通分支 $C$，并且不会访问到其他强连通分支 $C'$ 上去。否则就有第2条里所描述的边，使得 $f(C) < f(C')$。
4. 可以用归纳法完整证明。
