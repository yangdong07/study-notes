

上一章的问题是从一个特定源点开始，计算到其他所有点的最短路径。本章问题是，对图中的每对顶点，计算最短路径。
可以把单源最短路径算法运行 $|V|$ 次来解决每对顶点间的最短路径问题。如果所有边的权值是非负的，可以用Dijkastra算法：
1. 数组实现  $O(V^3)$
2. 二叉堆 稀疏图 $O(VE \lg V)$
3. 斐波那契堆 $O(V^2 \lg V + VE)$

如果有负权值边，就不能采用 Dijkstra 算法。对每个点运行一次 Bellman-Ford算法，运行时间为 $O(V^2E)$，在稠密图上运行时间为 $O(V^4)$

对每对顶点间的最短路径求解，输出形式为一个 $n \times n$ 的矩阵 $D=(d_{ij})$，其中 $d_{ij} = \delta(i, j)$ 为顶点 $i$ 和 $j$ 之间最短路径的权值。
还需要输出一个前驱矩阵 $\Pi = (\pi_{ij})$，其中 $\pi_{ij}$ 为从 $i$ 到 $j$ 的某条最短路径上 $j$ 的前驱顶点。由 $\Pi$ 矩阵的第 $i$ 行导出的子图应是以 $i$ 为根的一棵最短路径树。
对每个顶点 $i \in V$ ，定义 $G$ 对于 $i$ 的前驱子图为 $G_{\pi, i} = (V_{\pi, i}, E_{\pi, i})$，其中 $$ V_{\pi, i} = \{ j \in V: \pi_{ij} \neq NIL \} \cup \{i \} \\
E_{\pi, i} = \{(\pi_{ij}, j): j \in V_{\pi, i} - \{ i \}\}
$$

## 最短路径与矩阵乘法

每对顶点之间的最短路径，都具有最优子结构，可以通过动态规划算法解决。
定义一些符号标记：
- 邻接矩阵 $W = (w_{ij})$，如果 $(i, j) \in E$，$w_{ij}$ 为边 $(i,j)$ 的权值，否则为 $\infty$。
- $L^{(m)} = (l_{ij}^{(m)})$，$l_{ij}^{(m)}$ 表示从顶点 $i$ 到顶点 $j$ 的至多包含 $m$ 条边的任何路径的权值的最小值。换句话说，如果顶点 $i$ 到顶点$j$ 之间有一条最短路径，且边数不大于 $m$ ，则 $l_{ij}^{(m)}$ 有值，否则为 $\infty$。

当 $m = 0$ 时，从 $i$ 到$j$ 存在一条不包含边的的最短路径当且仅当 $i=j$，$$ l_{ij}^{(0)} = \left\{ \begin{array} {l}
0 \quad if \ i=j\\
\infty \quad if \ i \neq j
\end{array} \right.$$

对 $m \ge 1 $，先计算 $l_{ij}^{(m-1)}$。从顶点 $i$ 到 $j$ 的至多包含 $m$ 条边的最短路径，是从顶点 $i$ 到 $j$ 的所有前驱$k$ 的至多 $m-1$ 条边的最短路径加上 $(k,j)$ 中选择出来的，所以有：
$$ l_{ij}^{(m)} = \min{( l_{ij}^{(m-1)}, \min_{1 \le k \le n}{\{l_{ik}^{(m-1)} + w_{kj}\}})} = \min_{1 \le k \le n}{\{l_{ik}^{(m-1)} + w_{kj}\}}$$

因为如果不存在负权回路，最短简单路径最多只有 $n-1$ 条边，所以当 $m \ge n -1$时，$l_{ij}^{(m)}$ 不再发生变化：
$$ \delta(i j) = l_{ij}^{(n-1)} = l_{ij}^{(n)} = l_{ij}^{(n+1)} = \cdots $$

### 自底向上计算最短路径的权值
算法实际上是从 $W$ 和  $L^{(0)}$开始，按照矩形乘法不断计算 $L^{(m)}$ 的过程。
算法运行时间为 $O(V^4)$

### 改进运行时间
实际上可以使用**重复平方**技术减少矩阵乘法次数。另外，最终结果只需要 $m \ge n-1$ 就行了。所以只需计算 $\lceil \lg {(n-1)} \rceil$ 个矩阵乘积就可以了。算法运行时间降为  $O(V^3 \lg V)$

## Floyd-Warshall算法

另外一种动态规划思路：
设 $G$ 的顶点为 $V = \{1, 2, \cdots, n\}$，考虑某个顶点的子集 $ \{1, 2, \cdots, k\}$。
对任意一对顶点 $i, j\in V$，考察从 $i$ 到$j$ 的所有路径中，中间顶点皆属于集合 $ \{1, 2, \cdots, k\}$ 的路径。定义 $d_{ij}^{(k)}$ 为这样的路径的最小权值。如果这样的路径存在，则有值，否则值为 $\infty$。 $d_{ij}^{(n)}$ 即为最终的解。

考察 中间顶点皆属于集合 $ \{1, 2, \cdots, k\}$  的所有路径， 设 $p$ 是其中一条最小权值路径，分两种情况：
- $k$ 不是 $p$ 的中间顶点，则 $p$ 的中间顶点属于集合 $  \{1, 2, \cdots, k -1 \}$，  $d_{ij}^{(k)} = d_{ij}^{(k -1)}$
- $k$ 是 $p$ 的中间顶点，则 $p$ 可以分为 $i \leadsto k \leadsto j$ 两条最短子路径 $p_1$ 和 $p_2$ ，且 $p_1$ 和 $p_2$ 的中间顶点属于集合 $  \{1, 2, \cdots, k -1 \}$，所以 $d_{ij}^{(k)} = d_{ik}^{(k -1)} +  d_{kj}^{(k-1)} $

所以这种规划需要从两种最优子结构中选择一个构成问题的解：
$$d_{ij}^{(k)} = \left\{ \begin{array} {l}
w_{ij}    \quad if \ k = 0 \\
\min{(d_{ij}^{(k -1)}, d_{ik}^{(k -1)} +  d_{kj}^{(k-1)})} \ if \ k \ge 1
\end{array} \right .$$

此外还可以构造前驱矩阵 $\Pi$：
$$\pi_{ij}^{(0)} = \left\{ \begin{array} {l}
NIL    \quad if\ i = j \ or \ w_{ij} = \infty\\
i    \quad if\ i \neq j \ and \ w_{ij} < \infty\\
\end{array} \right .$$
$$\pi_{ij}^{(k)} = \left\{ \begin{array} {l}
\pi_{ij}^{(k-1)}    \quad if\  d_{ij}^{(k-1)} \le d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\\
\pi_{kj}^{(k-1)}    \quad if\  d_{ij}^{(k-1)} > d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\\
\end{array} \right .$$

### 运行时间分析
由于选择变少 $O(1)$，所以算法运行时间为 $O(V^3)$

### 有向图的传递闭包
已知一有向图 $G=(V, E)$，顶点集合 $V= \{ 1, 2, \cdots, n \}$，定义 $G$ 的传递闭包为图 $G^* = (V, E^*)$，其中 $$ E^* = \{(i,j): 图 G中存在一条从 i到j的路径 \}$$

使用Floyd-Warshall算法可以在 $\Theta(V^3)$ 时间内计算出 $d_{ij}$，如果 $i$ 和$j$ 之间存在路径，则 $d_{ij} < \infty$。

如果只是求传递闭包，实际上对权值并不关心，存在路径可以用bit表示，运算也可以用逻辑运算代替。


## 稀疏图上的Johnson算法

Jonhson算法的主要思想是结合 Bellman-Ford算法和 Dijkasta算法：
1. 通过 Bellman-Ford算法构造一个新的非负权值函数
2. 然后对每个点按新的权值函数运行 Dijkastra算法

所以算法的运行时间为：
1. 斐波那契堆 ： $O(VE + V^2 \lg V)$
2. 二叉堆：  $O(VE \lg V)$

稀疏图上，在渐进意义上比 Floyd-Warshall算法要快。

### 重赋权技术
Jonhson算法使用了重赋权技术。重赋权技术定义：
已知带权有向图 $G=(V, E)$，加权函数为$w: E\to \boldsymbol{R}$，设 $h: V \to \boldsymbol{R}$ 是将顶点映射到实数的任意函数，对每条边 $(u, v) \in E$，定义 $$ \hat{w}(u, v) = w(u, v) + h(u) - h(v)$$
可以证明如下性质：
1. 重赋权不会改变最短路径
2. 如果使用加权函数 $w$ 时， $G$ 中存在一条负权回路，当且仅当使用 $\hat{w}$ ,$G$ 中存在一条负权回路。

### 通过重赋权产生非负的权
在对图 $G$ 使用 Jonhson算法过程中，先加入一个源点 $s$，$s$ 到 $G$ 中所有点的权值为 0，即 $w(s, v) = 0$。可以通过从 $s$ 开始的Bellman-Ford算法计算出 $\delta(s, v)$，并且还可以判断有无负权回路。
令 $h(v) = \delta(s, v)$，定义新的加权函数为 $\hat{w}(u,v) = w(u, v) + h(u) - h(v) = w(u, v) + \delta(s, u) - \delta(s, v)$。由三角不等式 $\delta(s, v) \le \delta(s, u) + w(u, v)$ 可知： $\hat{w}(u, v) \ge 0$。

这样，使用新的加权函数，就可以在图 $G$ 上安全的使用 Dijkstra算法。
