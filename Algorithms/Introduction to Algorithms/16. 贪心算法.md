动态规划，解决方法是在所有子问题的分解中，选择一种来构造全局的最优解。通过比较所有子问题，选择一个子问题的最优解构造原问题的最优解。

贪心算法，每次只做一个局部最优的选择，来产生一个全局最优解。

## 活动选择问题

调度问题： 假设有一个需要使用某一资源（例如教室）的 $n$ 个活动组成的集合 $S = \{a_1, a_2, \cdots, a_n\}$。该资源一次只能被一个活动占用。每个活动 $a_i$ 有个开始时间 $s_i$ 和一个结束时间 $f_i$，且 $0\le s_i < f_i < \infty $。一旦被选择后，活动$a_i$ 就占据时间区间 $ [s_i, f_i)$。如果区间 $[s_i, f_i)$ 和 $[s_j, f_j)$ 互不重叠，称活动 $a_i$ 和 $a_j$ 是兼容的。
**活动选择问题就是要选出一个由互相兼容的活动组成的最大子集合。**

### 最优子结构
定义一个合适的子问题空间 $$ S_{i,j} = \{a_k \in S: f_i \le s_k < f_k \le s_j\}$$
这个集合中的所有活动都在活动 $a_i$ 结束之后开始，在活动 $a_j$开始之前结束。在时间轴表示为夹在 $a_i$ 和 $a_j$ 之间的所有活动。

先对所有活动按照结束时间进行排序：
$$f_0 \le f_1 \le f_2 \le \cdots \le f_n \le f_{n+1}$$

假设 $S_{i,j}$ 的解 $A_{i,j}$ 包含活动 $a_k$，则 $S_{i, j}$ 可以分解为 $S_{i, k}$ 和 $S_{k,j}$ 的解加上1（活动$a_k$）
在时间轴上表示，问题归约成 夹在 $a_i$ 和 $a_k$ 之间的活动集合 $S_{i, k}$，以及 夹在 $a_k$ 和 $a_j$ 之间的活动集合 $S_{k, j}$的问题

### 递归解
令 $c[i,j]$ 表示 $S_{i,j}$ 的最优解 $A_{i,j}$ 的活动的个数。则有递归式：
$$c[i, j] = \left\{
\begin{array}{l}
0 \quad if \ S_{i,j} = \varnothing \\
\max_{i < k < j, a_k \in S_{i,j}}{(c[i, k] + c[k, j] + 1)} \quad if \ S_{i,j} \neq \varnothing \\
\end{array} \right.
$$

### 贪心解
对于任意非空子问题 $S_{i,j}$，设 $a_m$ 是 $S_{i,j}$ 中具有最早结束时间的活动 $f_m = \min{\{f_k: a_k \in S_{i,j}\}}$

需要证明两点：
1. $a_m$ 一定出现在$S_{i,j}$的某个最优解（即最多兼容活动子集）里。也就是说，做一次贪心选择（取最早结束时间的活动），总可以产生最优解，是安全的。
2. 子问题 $S_{i,m}$ 非空，所以选择 $a_m$ 将使子问题 $S_{m,j}$ 为唯一可能非空的子问题。

_不知道为什么要证明第二点_

### 递归贪心算法和迭代贪心算法
贪心算法可以自顶向下的进行：每次进行一次贪心选择，然后在剩下的（唯一的？）子问题中找到最优解。


## 贪心策略的基本内容
贪心算法的设计模式：
1. 决定问题的最优子结构
2. 设计出一个递归解
3. **证明在递归的任一阶段，最优选择之一总是贪心选择。这样，贪心选择总是安全的，并且可以和剩下的子问题的最优解构成最优解**
4. _证明通过做贪心选择，至多剩下一个子问题_（其他子问题为空？）
5. 设计贪心策略的递归版本
6. 设计迭代版本

注意两个重要性质：
### 贪心选择性质
**一个全局最优解可以通过局部最优（贪心）选择来达到**
必须证明在每一步所做的贪心选择最终能产生一个全局最优解

### 最优子结构
**对一个问题来说，如果它的一个最优解包含了其子问题的最优解，则称该问题具有最优子结构**

意思是： 问题的最优解蕴含了其子问题也一定是最优解。 这个性质是用来对 动态规划以及贪心算法的可应用性进行评价的关键一点。

但是贪心算法还要证明： **将子问题的最优解与所做的贪心选择合并后，的确可以得到原问题的一个最优解。**

## 赫夫曼编码
压缩编码方式
固定长度编码
可变长度编码，压缩文件

前缀编码：没有一个编码是另一个编码的前缀。可以用树表示。
最优编码总是可以用满二叉树表示。叶子节点为待编码的字符，其路径为编码值。
给定对应的前缀编码的二叉树 $T$，很容易计算出编码一个文件所需的位数。对字母表 $C$中的每一个字符 $c$ ，设 $f(c)$ 表示 $c$ 在文件中出现的频度， $d_T(c)$ 表示$c$ 的叶子在树中的深度。注意$d_T(c)$ 也是字符$c$ 的编码的长度 这样，编码一个文件所需的位数就是
$$B(T) = \sum_{c\in C}{f(c)d_T(c)}$$
定义为树 $T$ 的代价。

### 构造赫夫曼编码
贪心算法基本思想：
1. 在字符集合 $C$中，选择频度最低的两个对象，合并成一个结点，频度等于二者之和。
2. 将该结点替换掉原来的两个对象，插入到 $C$ 中，构成一个新集合 $C'$。 $|C'| = |C| - 1$。在$C'$ 中递归求解。

这里贪心选择是：每次选择频度最低的两个对象。剩下的子问题在 $C'$ 集合中解决。

使用优先级队列 $Q$ 的 EXTRACT-MIN 和 INSERT操作来进行选择和插入，所用时间为 $O(\lg n)$。因为有 $n$ 个字符，要进行 $n$ 次（贪心选择、归约），所以总时间为 $O(n\lg n)$

#### 赫夫曼算法的正确性
主要证明：
1. ~~每一次贪心选择，都是问题的某个最优解的一部分。贪心选择是安全的。~~
2. 如果子问题 $C'$ 的解是最优的，加上贪心选择后构成的解是原问题 $C$ 的一个最优解。


_ 动态规划和贪心算法所能解决的问题，总是具有最优子结构的，这是基本特征。 但在贪心算法中，主要还要证明**将子问题的最优解与所做的贪心选择合并后，的确可以得到原问题的一个最优解**。_
