## 堆

描述：
- （二叉）堆数据结构是一种数组对象。
- 可以看做一颗完全二叉树
- 假设有 $n$ 个元素， 从上到下，从左到右，依次填满这颗树。序号与数组下标对应。
- $\textit{length}[A]$ 是数组中的元素个数
- $\textit{heap-size}[A]$是存放在A中的堆的元素个数
- $\textit{heap-szie}[A] \le \textit{length}[A]$
- 某个结点下标为 $i$，则
  - $PARENT(i) = \lfloor i / 2 \rfloor $
  - $LEFT(i) = 2i $
  - $RIGHT(i) =  2i + 1 $

### 最大堆
最大堆中，最大堆特性是指除了根以外的每个结点$i$，有：
$$ A[PARENT(i)] \ge A[i] $$

### 最小堆
除根以外的每个结点 $i$，有
$$ A[PARENT(i)] \le A[i] $$

## 最大堆上的操作

### MAX-HEAPIFY
输入： 数组$A$和下标 $i$
在调用时，假设以$LEFT(i)$ 和 $RIGHT(i)$ 为根的两棵二叉树都是最大堆。
但这时候 $A[i]$ 可以小于其子女。调用 MAX-HEAPIFY，就是将 $A[i]$ 下降到适当位置，使以 $i$ 为根的子树成为最大堆。

输出： 数组$A$，满足： 以$i$ 为根的子树是最大堆。

树高 为 $ \lfloor \lg{n} \rfloor $，直观上看，下降交换过程的运行时间为 $O(\lg{n})$

### BUILD-MAX-HEAP
将一个数组 $A[1..n]$ 变成一个最大堆。

因为子数组 $A[(\lfloor n / 2 \rfloor + 1)..n] $中的元素都是树中的叶子结点，这些叶子节点为根的树，默认满足最大堆特性。
所以从  $ \lfloor \textit{length} [A] / 2 \rfloor $ 到下标 1， 迭代调用 MAX-HEAPIFY，构建最大堆。

#### 分析
直观上，BUILD-MAX-HEAP的上界是 $O(n\lg{n})$
实际上，BUILD-MAX-HEAP 的渐进上界是 $O(n)$

### HEAPSORT 堆排序
排序的过程可以描述成：
1. 根节点$A[1]$ 最大，与$A[n]$交换，放在数组末尾
2. 堆长度$\textit{heap-size}[A]$ 减1
3. 对新的堆（根节点不满足最大堆特性，但子节点满足），执行一次 MAX-HEAPIFY(A, 1)
4. 重复 n - 1 次

最后可以得到排完序的数组

**运行时间  $O(n\lg{n})$**

## 优先级队列

实际中，快速排序的一个好的实现优于堆排序。
堆结构可以用作**优先级队列（priority queue）**

**优先级队列** 是一种用来维护由一组元素构成的集合$S$的数据结构，这一组元素中的每一个都有一个关键字 key。 一个最大优先级队列支持以下操作：
可以很快进行如下操作：

### $\text{MAXIMUM}(S)$ ： 返回 $S$中最大关键字的元素
最大堆的第一个元素。 $O(1)$

### $\text{EXTRACT-MAX}(S)$ ： 取出$S$中最大关键字的元素
1. 取出第一个元素，把优先级队列中最后一个元素放到第一个元素的位置，队列长度 - 1
2. 执行 $\text{MAX-HEAPIFY}(A, 1)$ 操作

运行时间： $O(\lg{n})$

### $\text{INCREASE-KEY}(S, x, k) $ ：将元素 $x$的值增加到 $k$
主要思想是从 $x$ 开始，与其父结点比较，冒泡方式上升。
上升高度不超过 树的高度，运行时间为 $O(\lg n)$

### $\text{INSERT}(S, x)$ ：把元素 $x$ 插入到集合 $S$
1. 先将一个结点赋最小关键字值（例如 $-\infty$），插入到队尾
2. 对这个结点恢复关键字值执行： $\text{INCREASE-KEY}(S, x, k)$

运行时间为 $O(\lg n)$
