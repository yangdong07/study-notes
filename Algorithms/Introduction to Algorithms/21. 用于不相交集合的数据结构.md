

## 不相交集合

不相交集合数据结构  disjoint-set data structure ，保持一组不相交的动态集合 $\mathcal{S} = \{S_1, S_2, \cdots, S_k\}$。每个集合通过一个代表来识别。代表是集合中的某个成员。

操作：
- $ \text{MAKE-SET} (x)$：建立一个新的集合，其唯一成员就是 $x$。因为要求集合是不相交的，所有要求 $x$ 不出现在其他集合里。
- $ \text{UNION}(x, y)$ ：将包含 $x$ 和 $y$ 的动态集合合并为一个新的集合。
- $ \text{FIND-SET} (x)$： 返回一个指针，指向包含 $x$ 的集合的代表。

### 应用举例
确定一个无向图中连通子图的个数，这些连通子图构成不相交集合。
1. 对图中所有点，MAKE-SET。
2. 对图中所有边，如果端点不在一个集合里面，执行 $UNION(x, y)$操作。

执行完之后，就得到了一个不相交集合。

## 不相交集合的链表表示
每个集合的域：
- $head$ 指向代表
- $tail$ 指向最后的对象

集合成员的域：
- 数据
- $next$ 指向下一个成员
- $leader$ 指向代表

对于各个操作：
- $ \text{MAKE-SET} (x)$，  $O(1)$
- $ \text{FIND-SET} (x)$，  $O(1)$
- $ \text{UNION}(x, y)$， 这个操作需要把一个链表接到另一个表的尾部，然后更新其 $leader$

对一个作用于 $n$ 个对象上的，包含 $m$ 个操作的序列：首先是 $n$ 个 $\text{MAKE-SET}$ 操作，然后是 $n-1$ 个 $\text{UNION}$ 操作， 需要 $\Theta(n^2)$ 时间，平均来看：一个操作的平摊时间为 $\Theta(n)$。

### 加权合并启发式策略 weighted-union heuristic
在合并的时候，总是把短的表接到长表的尾部，以减少更新次数。可以改善平摊时间。
可以证明：在这种策略下，一个包含 $m$ 个 $\text{MAKE-SET}$ 、 $\text{UNION}$ 和 $\text{FIND-SET}$ 操作（其中有 $n$个是 $\text{MAKE-SET}$ 操作）的序列所需时间为 $O(m + n\lg n)$

证明思路比较巧妙： 对一个固定的对象 $x$，更新一定发生在较小的集合中。一次更新后，集合中必定至少有两个元素；二次更新之后，集合中至少有4个元素；$k$ 次更新后至少有 $2^k$ 个元素。 对每个对象都是如此，每个对象至多被更新 $\lceil \lg n \rceil$ 次。所以更新 $n$ 个对象的总时间为 $O(n\lg n)$。
其他操作都有 $O(1)$ 的时间，所以总时间为 $O(m + n \lg n)$

## 不相交集合森林 disjoint-set forest
每个集合的域：
- $head$ 指向树根，即代表

集合成员的域：
- $p$ 指向父结点；根结点的$p$ 指向自己

对于各个操作：
- $ \text{MAKE-SET} (x)$，  $O(1)$
- $ \text{FIND-SET} (x)$，  运行时间与树高有关，沿着父结点找到根结点，即代表。
- $ \text{UNION}(x, y)$， 仅仅把一个根结点的 $p$ 指向另一个根结点。 $O(1)$

这里一个包含 $n-1$ 次$UNION$ 操作的序列可能会构造出一棵 $n$ 个结点的线性链的树。考虑两种启发式策略：
1. 按秩合并（union by rank）： 总是使包含较少结点的树的根指向包含较多结点的树的根。也可以用结点的高度表示 秩。
2. 路径压缩（path compression）：每次执行完 $\text{FIND-SET}$ 之后，把路径上的所有结点的$p$ 更新为 根结点。

如果仅使用按秩合并策略，运行时间为 $O(m \lg n)$
仅使用 路径压缩策略：最坏情况运行时间 $\Theta(n + f(1 + log_{2+ f/n}n))$
同时使用按秩合并和路径压缩时，最坏情况运行时间为 $O(m\alpha(n))$，其中$\alpha(n)$ 是一个增长极慢的函数。在任意可想象的不相交集合数据结构的应用中都有 $\alpha(n) \le 4$，所以可以认为 最坏情况运行时间为 $O(m)$， 每个操作的平摊时间为 $O(1)$

使用按秩合并和路径压缩策略后，不相交集合森林是目前已知的、渐近意义上最快的不相交集合数据结构。
