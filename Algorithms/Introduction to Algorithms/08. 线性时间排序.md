
### 比较排序 最坏情况的下界

**决策树模型**
比较排序可以抽象成为**决策树**（每次比较是一个结点，比较的最终结果是一个排序结果，是叶子结点）

**定理8.1 任意一个比较排序算法在最坏的情况下，都需要做 $\Omega(n\lg{n})$ 次比较**

## 非比较排序
对输入做了一些限制。可以在 $O(n)$运行时间排序

### 计数排序
假设 $n$个输入元素中的每一个都是介于 $0$ 到$k$ 之间的整数。此处$k$为整数。当 $k = O(n)$时， 计数排序的运行时间为  $\Theta(n)$

计数排序的基本思想是对每一个输入元素$x$，确定出小于 $x$ 的个数 $c_x$，然后把 $x$ 放在第 $c_x$位。

描述：
1. 输入数组 $A[1..n]$
2. 计数数组 $C[0..k]$，用于计每个数出现的次数。
3. 在数一遍之后，累加 $C[0..k]$，就可以得到在这个数及其之前共有多少个数字。
3. 输出结果数组 $B[1..n]$，按输入顺序，把相应的数按照其计数放到$B[1..n]$对应位置。

总的运行时间为 $\Theta(n+k)$

计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与在输入数组中的次序相同。
一般当卫星数据随着排序的元素一起移动时，稳定性显得比较重要。
基数排序也需要利用到计数排序的稳定性。

### 基数排序 radix sort
设有 $n$ 个 $d$ 位数，基数排序从最低位开始，按位对每个数相同位进行**稳定**排序。执行 $d$ 次排序。

如果每个数位有 $k$ 种取值的可能， 使用计数排序（稳定排序，运行时间 $\Theta(n+k)$）按位排序，基数排序的运行时间是 $\Theta(d(n+k))$。

对于$n$个二进制数字（$b$位），划分成 $\lceil b/r \rceil$ 个 $r$ 位数字，则每个数位有 $k = 2^r$ 个取值，使用基数排序，运行时间为 $\Theta((b/r)(n+2^r))$

如果 $b = O(\lg{n})$， $r = \lg{n}$，$\Theta((b/r)(n+2^r))$这个值会最优，约为 $\Theta(n)$


### 桶排序（bucket sort）
**假设输入是均匀分布在某一个区间。**

桶排序的思想就是把这个区间划分成 $n$个相同大小的子区间，然后把$n$个输入插入到各个桶里（链表），对每个桶里的数据进行排序（可以用插入排序），最后合并

如果输入是均匀分布的，且对桶的排序是插入排序 $O(n^2)$，可以证明通排序算法的运行时间为 $\Theta(n)$
