


## 最短路径
已知一个带权有向图 $G=(V, E)$，和加权函数 $w: E \to \boldsymbol{R}$ 为从边到实数权值的映射。路径 $p = \langle v_0, v_1, \cdots, v_k \rangle$ 的权是指其组成边的的所有权值之和：$$ w(p) = \sum_{i=1}^k{w(v_{i-1}, v_i)} $$ 定义从 $u$ 到 $v$ 间的**最短路径的权**为：
$$ \delta(u, v) = \left\{
\begin{array} {l}
\min{\{w(p): u \leadsto v \}}  \quad if \ p\ exist \\ \infty \quad else \\
\end{array} \right. $$
从顶点$u$ 到顶点 $v$ 的**最短路径**定义为权 $w(p)=\delta(u, v)$的任何路径。

广度优先搜索算法（BFS）实际上是无权图的最短路径算法

## 单源最短路径问题
已知图 $G=(V, E)$，从源点 $s$ 出发，找出从 $s$ 到每个顶点 $v \in V$ 的最短路径。

单源最短路径问题的变体：
- **单终点最短路径问题**：把每条边反向。
- **单对顶点最短路径问题**：给定某对顶点 $u$ 和 $v$ ，找出从$u$ 到$v$ 的一条最短路径。实际上，解决了单源最短路径问题，可以找出 $u$ 到所有点的最短路径。此外，从渐进意义上看，目前还没有比最好的单源算法更快的算法来解决这一问题。
- **每对顶点间最短路径问题**：对于每对顶点$u$ 和$v$ ，找出从 $u$ 到 $v$ 的最短路径。可以对每个顶点运行一次单源算法；也有别的方法（下一章）

### 最短路径的最优子结构
**对于一个给定的带权有向图 $G=(V, E)$，和加权函数 $w: E \to \boldsymbol{R}$ 。设路径 $p = \langle v_1, \cdots, v_k \rangle$ 是从 $v_1$ 到 $v_k$ 的最短路径。对于任意 $i,j$，其中$1\le i \le j \le k$，设 $p_{ij}= \langle v_i, v_{i+1}, \cdots, v_{j} \rangle$ 为 $p$ 中从 $v_i$ 到 $v_j$ 的自路径，那么， $p_{ij}$ 是从 $v_i$ 到 $v_j$ 的最短路径。**

### 负权值边和负权回路
如果图中存在一条负权回路，即回路的边的权值的和为负数。那么，这条回路上的点都不可能存在最短路径。

Dijksra算法需要假设输入的图的权值都是非负的。
Bellman-Ford算法允许负权值边的存在，还可以检测出负权回路。

### 最短路径中不可能存在回路
负权回路和正权回路都不可能存在。
0权回路可以移去而不影响。

### 松弛技术
对每个顶点 $v\in V$，设置一个属性 $d[v]$，用来描述从源点 $s$ 到 $v$ 的最短路径上权值的上界，称为 **最短路径估计**。
初始化：
1. 对所有$v$， $d[v] = \infty, \pi[v] = NIL$
2. $d[s] = 0$

```
RELAX(u, v, w)
if d[v] > d[u] + w(u, v)
  d[v] = d[u] + w[u, v]
  π[v] = u
```

### 最短路径以及松弛的性质

#### 三角不等式
对任意边 $(u, v) \in E$， 有 $\delta(s, v) \le \delta(s, u) + w(u, v)$
#### 上界性质
对任意顶点 $v \in V$， 有 $d[v] \ge \delta(s, v)$， 而且一旦 $d[v]$ 达到 $\delta(s, v)$ 值就不再改变
#### 无路径性质
如果从 $s$ 到 $v$ 不存在路径，则总是有 $d[v] = \delta(s, v) = \infty$
#### 收敛性质
如果从 $s\leadsto u \to v $是图 $G$ 某 $u, v\in V$ 的最短路径，而且在松弛边$(u, v)$ 之前的任何时间 $d[u] = \delta(s, u)$， 则在松弛边$(u, v)$的操作过后 $d[v] = \delta(s, v)$
#### 路径松弛性质
如果 $p = \langle v_0, v_1, \cdots, v_k \rangle$ 是从 $s=v_0$ 到 $v_k$ 的最短路径，而且 $p$ 的边按照 $(v_0, v_1),(v_1, v_2),\cdots,(v_{k-1}, v_k)$ 的顺序进行松弛，那么 $d[v_k] = \delta(s, v_k)$。这个性质的保持并不受其他松弛操作的影响，即使它们与 $p$ 的边上的松弛操作混在一起也是一样的。


## Bellman-Ford算法
```
BELLMAN-FORD(G, w, s)
INITIALIZE-SINGLE-SOURCE(G, s)
for i in range(0, |V| - 1):
  for each edge (u, v) ∈ E:
    RELAX(u, v, w)
for each edge(u, v) ∈ E:
  if d[v] > d[u] + w(u, v)
    return FALSE
return TRUE
```

主要思想：从源点$s$ 开始，对每条边进行一次RELAX操作；重复 $|V|-1$ 次。然后对每条边检查 $d[u]$ 和 $d[v]$ 是否满足三角不等式，如果不满足，说明有负权回路存在；否则，则可以通过每个点的 $\pi[v]$ 构成一个前驱子图，亦即最短路径树。

### 运行时间 $O(V) + O(VE) + O(E) = O(VE)$

## 有向无回路图中的单源最短路径
对加权dag图，可以按照拓扑顺序进行松弛，能够在 $\Theta(V + E)$ 时间内计算出单源最短路径。

主要步骤：
1. 对dag图进行拓扑排序（一次DFS），$\Theta(V+E)$
2. 初始化， $\Theta(V)$
3. 按拓扑序，对每个点的邻接表中的边进行松弛。共有 $|E|$ 条边。

所以总运行时间为 $\Theta(V+E)$

## Dijkstra 算法
类似于BFS和 最小生成树的Prim算法。
Dijkstra 算法是贪心算法。
Dijkstra 算法假设每条边的权值都是非负的。

算法主要步骤：
1. 松弛初始化。初始化一个最小优先级队列为所有顶点，关键字为 $d[v]$ 值。
2. 对队列$Q$，每次取出 $d[v]$ 值最小的点，对这个点的所有边进行一次松弛。
3. 重复第2步操作，直到取出所有点

算法的每一次选择都是贪心选择（取 $d[v]$ 最小的点）。证明算法正确性的关键是证明每当一个顶点$u$ 被取出的时候，都有 $d[u] = \delta(s, u)$。


### 算法分析
Dijkstra算法使用了最小优先级队列的三个操作：
- INSERT （初始化）， 共$|V|$次操作
- EXTRACT-MIN，   共 $|V|$ 次操作
- DECREASE-KEY （在松弛步骤中更新 $d[v]$值），共 $|E|$ 次操作

算法运行时间取决于最小优先级队列的数据结构。
1. 数组实现
    1. INSERT和DECRESE-KEY均为 $O(1)$
    2. EXTRACT-MIN 为 $O(V)$
    3. 总时间为 $O(V^2 + E) = O(V^2)$
2. 二叉堆（稀疏图 $E = o(V^2/\lg V)$）
    1. 初始化操作需要 $O(V)$
    2. EXTRACT-MIN 为 $O(\lg V)$
    3. DECREASE-KEY 为 $O(\lg V)$
    4. 总时间为 $O((V + E) \lg V) = O(E \lg V)$
3. 斐波那契堆
    1. 初始化操作需要 $O(V)$
    2. EXTRACT-MIN 为 $O(\lg V)$
    3. DECREASE-KEY 平摊时间为 $O(1)$
    4. 总时间为 $O(V \lg V + E)$

## 差分约束和最短路径

### 线性规划问题
linear programming problem
给定一个 $m \times n $ 的矩阵 $A$，一个 $m$ 维向量 $b$ 和一个 $n$ 维向量 $c$，我们希望找出由 $n$ 个元素组成的向量 $x$ ，在由 $Ax \le b$ 所给出的 $m$ 个约束条件下，使目标函数 $\sum_{i=1}^n{c_ix_i}$ 最大。

### 差分约束系统
system of difference constraints 是线性规划问题的一种特殊情况：矩阵 $A$ 中的每一行 只有一个 $1$ 和 一个 $-1$，$A$ 的其他所有元素都为 0。因此，由 $Ax \le b$ 给出的约束条件是 $m$ 个差分约束集合，其中包含 $n$ 个未知元。每个约束条件是简单的线性不等式：
$$ x_j - x_i \le b_k$$ 其中 $1 \le i, j\le n, 1 \le k \le m$。

**如果 $x= (x_1, x_2, \cdots, x_n)$ 是差分约束系统 $Ax \le b$ 的一个解， $d$ 为任意常数，则 $x + d = (x_1 + d, x_2 + d ,\cdots, x_n + d)$ 也是该系统的解。**

### 约束图
可以将差分约束系统转成图，其中每个未知量 $x_i$  对应一个顶点 $v_i$。$x_i$和$x_j$ 之间的约束 $x_j - x_i \le b_k$ 可以用边 $(v_i, v_j)$表示，且 $w(v_i, v_j) = b_k$。
如果这个图不包含负权回路，那么 $$ x = (0, \delta(v_1, v_2), \delta(v_1, v_3), \cdots, \delta(v_1, v_n))$$ 是此系统的一个可行解。如果图包含负权回路，则此系统不存在可行解。

对于 $n$ 个未知量和 $m$ 个约束条件的差分约束系统，使用Bellman-Form算法对其约束图进行求解，运行时间为 $O(nm)$
