B树 是用于磁盘或其他存储设备而设计的一种平衡查找树。

B树的主要特点是可以减少磁盘存取次数。

对一个磁盘而言，一次性读写一片区域（一页）是效率最高的。 B 树的设计考虑到这一点，将一个结点对应一页，树的高度为 $h$ ，每种类型的操作只是沿着树下降，并在下降过程完成（不用回溯），则对磁盘的操作次数为 $O(h)$ 。


## B树的定义
一棵 B树$T$ 是具有以下性质的有根树（根为 $T.root$）：
1. 每个节点 $x$ 有以下域：
  1. $x.n$：存储在结点 $x$ 中的关键字的个数
  2. $x.keys$：存储在结点 $x$ 中的关键字，以非降序存放： $x.key_1 \le \cdots \le x.key_{n[x]}$
  3. $x.leaf$：布尔值，如果 $x$ 是叶子，则为 TRUE，否则为 FALSE
2. 每个内结点 $x$ 还有 $x.n + 1$ 个指向其子女的指针 $x.c_1, x.c_2, \cdots, x.c_{x.n+1}$。叶子结点无子女，故无 $c_i$ 字段。
3. 关键字 $x.key_i$ 对子树中的关键字范围加以分隔，如果 $k_i$ 为存储在以 $x.c_i$ 为根的子树中的关键字，则有 $$ k_1 \le x.key_1 \le k_2 \le x.key_2 \le \cdots \le x.key_{x.n} \le k_{x.n+1} $$
4. 每个结点能包含的关键字数有一个上界和下界，可以用 B树 的 **最小度数** $t$ 来表示，$t\ge 2$：
  1. 如果树是非空的，则根结点至少包含1个关键字
  2. 每个非根结点必须至少有 $t-1$ 个关键字。每个非根的内结点至少有 $t$ 个子女。
  3. 每个结点可包含至多 $2t-1$ 个关键字。所以每个内结点至多有 $2t$ 个子女。如果一个结点有恰好 $2t-1$ 个关键字，则称为 **满** 结点。

$t=2$ 时B树是最简单的，每个内结点有 2、3、4个子女，又称 2-3-4树。

### 如果 $n \ge 1 $，则对任意一棵包含 $n$ 个关键字、最小度数 $t \ge 2$ 的B树的高度有  $$ h \le \log_t{\frac{n+1}2} $$
如果 $t$ 很大，则树会很矮。

## 对 B 树的基本操作
约定：
1. B树的根结点始终在主存中，因而无需对根做 DISK-READ；但是，当根结点被改变后，需要对根节点做一次DISK-WRITE
2. 任何被当做参数的结点被传递之前，要先对他们做一次 DISK-READ。

算法都是 “单向”的，沿树的根下降，没有任何回溯
在理解算法的时候可以根据B树性质，勾勒出大致的动画。

### 搜索B树：查询操作
设待查找关键字为 $k$
思路：从根结点开始，遍历结点内的关键字，看$k$ 落在哪个范围里。如果$k$ 为某个关键字，则返回。否则，在范围内的子树 $c_i[x]$中继续查找。

- 磁盘操作次数 $O(\log_t{n})$
- CPU时间： $O(th) = O(t \log_t{n})$

### 创建一棵空的B树
主要创建一个根节点，可以为空。只需要 $O(1)$ 的磁盘操作和 $O(1)$ 的CPU时间

### 向B树中插入关键字：修改操作
注意任何对具有特定性质的数据结构的修改操作，都要维护数据结构的性质。
在向 B树插入关键字的时候，主要保证每个结点的关键字个数符合要求（对于非根结点有： $ t-1 \le x.n \le 2t-1$ ）。
如果插入一个关键字使得结点的关键字个数超过 $2t-1$，则需要分裂结点，把中间关键字上移。这种方式需要递归回溯。

另一种思路是，保证要插入的树的根结点是非满的。主要思路如下：
1. 如果根结点满了，则将根结点一分为二，中间的关键字构成新的根结点。树的高度+1。这里是树长高的唯一途径。
2. 如果要插入的子树的根结点 $x$ 是非满的。如果是结点是叶子，直接插入即可；如果是内结点 ，检查要插入的位置对应的子树的根结点 $x.c_i$，先检查是不是满的。如果是满的，将其分裂，然后把中间关键字取出来，放到 $x$ 结点中。$x$ 的关键字数 + 1，原来的 $x.c_i$ 变成2个指针。这时候 $x$ 可能是满的，也可能非满，并不重要，且树的高度也不增加。得到一棵待插入的非满的子树之后，继续执行插入操作。

可以构造一副动态图：从一棵空树开始插入，根结点（此时也是叶子结点）首先被填满，然后分裂：变成根结点和两片叶子，根结点只有一个关键字。随后叶子被填满，分裂成两片叶子，并将中间的元素“挤”上去，根结点的关键字数增加。随着叶子不断地分裂，根结点的关键字又满了，此时根结点再次分裂，变成根结点和两个半满的内结点，以及若干叶子。 继续的插入，叶子填满、分裂，内结点关键字数增加，填满、分裂，根结点关键字数增加，填满，分裂，长高。

注意这里最终的插入一定落到一个非满的叶子上面（因为在插入之前就先判断并分裂了满的结点）。除了根结点的分裂，其他都是平级上的分裂，不会引起树高度的增加。

- 磁盘操作次数 $O(\log_t{n})$
- CPU时间： $O(th) = O(t \log_t{n})$
- 在任何时刻，需要留在主存中的页面数为 $O(1)$

### 从B树中删除关键字：修改操作
同样注意维护数据结构的性质。这里主要保证在删除某个关键字之后，每个结点的关键字个数至少为 $t-1$。 这里可以加强条件：保证在删除某个关键字之前，每个结点的关键字个数至少为 $t$。

如果说插入（增长）导致分裂，那么删除会引起“融合”：
1. 如果关键字在叶子结点里，直接删除。（但是前提是叶子中关键字个数 $ \ge t$，这样删除后至少有 $t-1$个关键字，保持B树性质。这个前提会通过提前检查、拆东补西或者直接合并确保）
2. 如果关键字$k$在内结点中：
    1. 如果结点 $x$ 中前于 $k$ 的子结点 $y$包含至少 $t$个关键字，则找出 $k$ 在以 $y$ 为根的子树中的前驱 $k'$。递归删除 $k'$，并在 $x$ 中用 $k'$取代 $k$。
    2. 对称的，如果结点 $x$ 位于 $k$ 之后的子结点 $z$ 包含至少 $t$ 个关键字，则找出 $k$ 在以 $z$ 为根的子树中的后继 $k'$。递归删除 $k'$，并在 $x$ 中用 $k'$取代 $k$。
    3. 否则，如果 $y$ 和 $z$ 都只有 $t-1$ 个关键字，将 $y,k,z$ 关键字在 $y$上合并，这样 $x$ 中的关键字个数减少 1， $y$ 中的关键字个数位 $2t-1$。在 $y$ 中**递归删除** $k$。（注意不是直接删除）
3. 如果关键字$k$不在内结点 $x$中，则一定存在于某个 $x.c_i$ 为根的子树中（如果$k$ 确实在树中）。这里我们需要确保删除前 $x.c_i$结点的关键字个数至少为 $t$。
    1. 如果$x.c_i$ 只有 $t-1$个关键字，但其相邻兄弟包含至少 $t$ 个关键字，则将 $x$ 中的某个关键字降至 $x.c_i$ 中，将 $x.c_i$ 相邻兄弟中的某个关键字升至 $x$，相应子女指针移到 $x.c_i$ 中。保证 $x.c_i$ 中至少 $t$ 个关键字。“拆东补西”
    2. 如果$x.c_i$及其相邻兄弟都只有 $t-1$个关键字，则将 $x.c_i$ 与一个兄弟合并，并将 $x$ 的一个关键字移至新合并的结点，使之成为该结点的中间关键字。
        1. 如果 $x$ 不是根结点，此时 $x$ 的关键字数减 1，可能为 $t-1$，但是并不重要，删除操作继续从子树的根结点进行，且子树的根结点至少有 $t$ 个关键字。$x$ 可能会在将来某个时候被补充到 $t$ 个关键字。
        2. 如果 $x$ 是根结点，只要至少有一个关键字都是符合 B 树性质的。当某次操作把结点内唯一的关键字下移时，就要改变树根的位置，树的高度减 1。这是唯一降低树高度的地方。

主要注意两点：
1. 实际的删除一定是落在叶子结点上。
2. 在删除前，确保非根结点上的关键字个数至少为 $t$，这个通过拆借或合并确保。
3. 根结点上至少要有一个元素，如果发生了合并，唯一的元素下移，则将根结点也下移，释放旧根。

删除操作的动态图可以描述为： 删除（叶结点上的关键字）、融合、关键字下移、根下移。整棵树从叶结点开始收缩，变小。

插入实际上也是从叶结点（最初的根结点）开始，生长、分裂，整棵树变大。
