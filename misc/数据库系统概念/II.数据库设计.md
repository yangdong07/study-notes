## 第七章 数据库设计和 E-R模型

E-R模型： 实体（entity）-联系（relationship）模型。

### 设计过程概览

数据库设计，包括 数据模型选择、概念设计、功能需求、逻辑设计、物理设计几个阶段。

设计是一个复杂的过程，需要迭代。 好的设计需要科学和“好的品味”的结合。

两个主要的设计缺陷：
- 冗余： 一个不好的设计可能会重复信息。尽量避免冗余信息的出现。如果出现冗余信息，可能需要在多个地方更新、修改数据，不容易保证数据一致性。
- 不完整： 信息不完整，这一点是冗余的对立面，同样也要避免。

### Entity-Relationship 模型

- **实体（entity）**，可以理解成现实世界中可区别的一个对象或一个“事物”。 比如每个人都是一个实体。

- **实体集**，是相同类型即具有相同性质（或属性）的一个实体集合。

- **联系（relationship）** 是指多个实体间的相互关联： 比如一个学生学习一门课程。 学生和课程是两个实体，学习形成了一种联系。

- **联系集（relationship set）** 是相同类型联系的集合。

- 实体集之间的关联称为 **参与（paritcipate）**。

- 实体在联系中扮演的功能称为实体的 **角色（role）**。 由于参与一个联系集的实体集通常是互异（不同）的，所以角色是隐含的并且一般并不指定。如果同一个实体集参与一个联系集，需要指明角色。

- 联系也可以具有 **描述性属性（descriptive attribute）**。

- 参与联系集的实体集的数目称为联系集的 **度（degree）**。 二元联系集、n元联系集。

#### 属性

- 简单（simple） 和 复合（composite）属性。 复合属性可以划分成更小的部分。
- 单值（single-valued）和多值（multivalued）属性。 多值属性可以限制数目上下界
- 派生（derived）属性。 有些属性可以从基属性计算得到，比如年龄可以从生日计算得到。这些属性一般不存储，在需要的时候计算得到。

#### 映射基数

**映射基数（mapping cardinality），或基数比率，表示一个实体通过一个联系集能关联的实体的个数。**

- **一对一**。 A中的一个实体至多与B中的一个实体相关联； B中的一个实体至多与A中的一个实体相关联。
- **一对多**。 A中的一个实体可以与B中的任意数目（0或多个）实体相关联； B中的一个实体至多与A中的一个实体相关联。
- **多对一**。 A中的一个实体至多与B中的一个实体相关联。 B中的一个实体可以与A中的任意数目（0或多个）实体相关联。
- **多对多**。 A中的一个实体可以与B中的任意数目（0或多个）实体相关联。 B中的一个实体可以与A中的任意数目（0或多个）实体相关联。

解读： 注意 一对多 和多对一。 一个和多个实体相关联这个是字面意义，但是还要注意一点： 多的这一侧，每个实体只能与至多一个实体（一的这一侧）相关联。注意必须有这个限定，否则， 就是多对多的关系。


有时候用 $l\dots h$ 表示映射基数的上下界： 比如： $1..1$ 表示每个实体至少一个，至多一个关联； $0..1$ 表示每个实体至多一个关联，可以用在 “多” 侧； $0.. * $表示每个实体可以有任意数目的关联。 可以用在 “一” 侧。 注意这里的概念有一点违背直觉，注意即可。

#### 参与约束

- 如果实体集E中的每个实体都参与到联系集R的至少一个联系中，实体集E在联系集R中的参与称为 **全部（total）** 的
- 如果 E中只有部分实体参与到联系集 R中，则称为 **部分（partial）的** 。

解读： $1.. * $ 如果映射下届是1，表示每个实体都至少有一个关联， 这说明参与是 全部的。 $0.. * $ 表示参与是部分的： 实体可以没有关联。

#### 从实体集中删除冗余属性

映射基数可以帮助理解冗余属性。 比如 每个导师实体有一个 系名（dept_name)属性。 导师与系关系是 多对一的： 每个导师必须从属于一个系； 每个系可以有任意数量导师。

如果建立 导师与系的 联系集， 则导师实体中的系名属性是冗余的。可以去除。

**如果存在联系集， 实体集中的一些属性可能是冗余的。**

#### 弱实体集

如果一个实体集 A 中每个实体，都从属于另一个实体集 B 中某个实体， 多对一的关系。 并且 A中的实体必须有 B 的主码（属性）才能构成完整主码。

这种没有足够的属性以形成主码的实体集称作 **弱实体集（weak entity set）**。 弱实体集必须与另一个称为 **标识（identifying）** 或 **属主实体集（owner entity set）** 的实体集关联才能有意义。

这里其实有几个意思：

1. 如果 A 和 B 没有联系，A 当然可以自定义主码。 但是 A 是从属于 B的。 A和B之间存在联系； A需要B的主码，以构成完整主码。
2. 如果 A 中 使用B的主码（重复），实际上产生了 **冗余**， 为了避免这个问题，定义 A 为弱实体集， 必须与 标识实体集关联。 也就是说，弱实体集 **存在依赖（existence dependent）** 于标识实体集。 其联系称为 **标识性联系**。

弱实体集其实很容易见到。。


#### 实体-联系图

- 实体集： 分成两部分的矩形（上部名称，下部属性列表）
- 联系集： 菱形
- 联系集属性： 未分割的矩形
- 联系集与联系集属性： 虚线连接
- 实体集参与联系集： 线段
- 实体集参与联系集，映射基数为 $1..1$， 双线
- 实体集参与联系集，映射基数为 $0..* $， 从联系集到实体集的箭头（这样理解，这一侧表示一对多的“一”侧， 另一侧实体汇集的方向。）
- 一对一：  两侧都是箭头
- 一对多和多对一： “多”侧 箭头； “一”侧线段
- 多对多：  两侧都是线段
- 标志性联系集，用于连接到弱实体集： 双菱形

### E-R模型 转 关系模式

- 具有简单属性的强实体集的表示， 很简单，一个table
- 具有复杂属性的强实体集的表示
    - 派生属性： 不存储值，使用时计算
    - 复合属性： 将属性分解成若干子属性
    - 多值属性： 可以创建一个新的关系模式（一对多的关系）
- 弱实体集的表示
    - 对应关系模式实际上就是 外码 和外码参照约束。
    - 还可以设置 “级联删除”
- 联系集表示， 也是一个关系表，注意主码集合
    - 多对多二元关系， 参与实体集的主码属性的并集成为主码
    - 一对一， 任意一个实体集的主码都可以选做主码。
    - 一对多或者多对一， “多”的那一侧（映射基数为 $0..1$）的实体集的主码构成主码
    - n元关系集边上没有箭头： 所有参与实体集的主码属性的并集成为主码
    - n元关系集边上有一个箭头： 不在“箭头”侧的实体集的主码属性为模式的主码。（ **一个联系集外只允许一个箭头**？？？）

### 扩展的 E-R特性

- 特化，类似于类派生的概念，自顶向下
- 概化， 类似于类抽象的概念， 自底向上
- 属性继承
- 概化上的约束：
    - 不相交（disjoint）
    - 重叠（overlapping）
- 聚集： 这样理解聚集， 可以将 若干实体集的联系集作为一个实体，与另一个实体集产生联系。


### 统一建模语言 UML

- 类图（class diagram），与 E-R图相类似
- 用况图（use case diagram），用户与系统之间的交互
- 活动图（activity diagram），系统不同部分之间的任务流
- 实现图（implementation diagram）。

### 数据库设计的其他方面

数据库设计是一个很复杂的过程，涉及很多方面。以上只是理论上最简单的部分。

- 数据约束与关系数据库设计， 最基本的
- 使用需求： 查询、性能
- 授权需求： 考虑不同用户对于数据的访问权限。有时候是同一份数据不同属性的访问权限。 权限粒度。
- 数据流、工作流： 在对数据的操作过程中，数据的控制权会在不同的负责人员之间传递。


**数据库设计在两个意义上式面向人的工作： 系统的最终用户是人； 数据库设计者需要与应用领域的专家进行广泛交互以理解应用的数据需求。**


## 第八章 关系数据库设计

这一章主要介绍范式相关概念。理解起来比较困难。

### 原子域与第一范式

- E-R模型允许属性具有子结构（多值或者组合），但在关系模型，创建表时，要消除这种子结构
    - 多值属性： 为每个项创建一条元组
    - 组合属性： 每个子属性单独作为一个属性
- 关系模型中，将属性不具有任何子结构这个思想形式化。
    - 一个域是原子的（atomic），如果该域的元素被认为是不可分的单元
    - 如果关系模式 R 的所有属性的域都是原子的， 则称 R 属于 **第一范式（First Norm Form， 1NF）**

有时候强制使用第一范式，会给应用程序员造成不必要的负担。 现代数据库系统却是支持很多类型的非原子值。


### 函数依赖

现实世界会有一些约束，比如一个孩子只有一个父亲、一个母亲。 这种约束在数据库中以函数依赖的形式定义。

对于一个关系模式，需要先找出其需要满足的函数依赖集合 $F$。根据 $F$ 可以判断关系模式的设计是否属于某个 **范式**

函数依赖概念是定义 BCNF、3NF、4NF的基础。下面是相关概念和定义。

- $r(R)$ 是一个关系模式，其属性集合为 $R$
- $\alpha \subseteq R$， $\beta \subseteq R$ 是 $R$ 的两个子集
- 给定 $r(R)$ 的一个实例， 这个实例 **满足函数依赖 $\alpha \to \beta$** 的条件是： 对实例中所有元组对 $t_1$ 和 $t_2$，若 $t_1[\alpha] = t_2[\alpha]$， 则 $t_1[\beta] = t_2[\beta]$
- 如果在 $r(R)$ 的每个合法实例中都满足函数依赖 $\alpha \to \beta$，则我们说该函数依赖在模式 $r(R)$ 上 **成立（hold）**

上面是形式化定义，其实从例子很容易看出来什么是函数依赖

| $\alpha$ | $\beta$     |
| :------------- | :------------- |
| $a_1$       | $b_1$       |
| $a_1$       | $b_1$       |
| $a_2$       | $b_2$       |
| $a_2$       | $b_2$       |
| $a_3$       | $b_2$       |
| $a_3$       | $b_2$       |

如上表所示： 如果 $\alpha$ 对应的属性的值相同，则 $\beta$ 也相同， 这称为 $\alpha \to \beta$ 函数依赖。 注意这里 $\alpha$ 可能是超码，不会重复。 这里为了说明概念，特意显示的重复。

- 从函数依赖可以形式化定义超码： 如果函数依赖 $K \to R$ 在 $r(R)$ 上成立，则 $K$ 是 $r(R)$ 的一个超码。
- 有些函数依赖称为 **平凡的（trivial）**，因为它们在所有关系中都满足。一般地，如果 $\beta \subseteq \alpha$，则 函数依赖$\alpha \to \beta$ 总能满足，这种函数依赖是平凡的。

#### 函数依赖集的闭包

可以从一个函数依赖集扩展得到 **闭包**。

- 给定关系模式 $r(R)$，如果 $r(R)$ 的每一个满足 $F$ 的实例也满足 $f$，则 $R$ 上的函数依赖 $f$ 被 $r$ 上的函数依赖集 $F$ **逻辑蕴含（logically imply）**
- $F$的闭包 是被 $F$ 逻辑蕴含的所有函数依赖的集合。 字面理解，就是从 $F$ 推导出的所有函数依赖。


Armstrong公理（Armstrong's axiom）：

- 自反律（relexivity rule）： 如果 $\beta \subseteq \alpha$， 则 $\alpha \to \beta$ 成立
- 增补律（augumentation rule）： 如果 $\alpha \to \beta$ 成立，则 $\gamma \alpha \to \gamma \beta$ 成立
- 传递律（transitivity rule）：如果 $\alpha \to \beta$ 和 $\beta \to \gamma$ 成立， 则 $\alpha \to \gamma$ 成立

补充：

- 合并律（union rule）： 若 $\alpha \to \beta$ 和 $\alpha \to \gamma$ 成立，则 $\alpha \to \beta \gamma$ 成立。
- 分解律（decomposition）： 若 $\alpha \to \beta \gamma$ 成立，则 $\alpha \to \beta$ 和 $\alpha \to \gamma$ 成立
- 伪传递律（pseudotransitivity)： 若 $\alpha \to \beta$ 和 $\gamma \beta \to \delta$ 成立， 则 $\alpha \gamma \to \delta$ 成立。

可以基于这些公理、定律推导出  $F^+$。 注意，由于包含 $n$ 个元素的集合（$R$）有 $2^n$ 个子集，共有 $2^n \times 2^n$ 个可能的函数依赖。

#### 属性集的闭包

如果 $\alpha \to B$ ，则称属性 $B$ 被 $\alpha$ **函数确定**。

令 $\alpha$ 为一个属性集，将函数依赖集 $F$ 下被 $\alpha$ 确定的所有属性的集合称为 $F$ 下的$\alpha$ 的闭包，记为 $\alpha^+$

计算 属性集闭包的算法称为 属性闭包算法。其作用是：

1. 判断 $\alpha$ 是否为超码： 检查 $\alpha^+$ 是否包含所有属性。
2. 通过检查是否 $ \beta \subseteq \alpha^+$ ，判断 函数依赖 $\alpha \to \beta$ 是否成立（相当于是否 $ {\alpha \to \beta} \subseteq F^+$）。
3. 另一种计算 $F^+$ 的方法： 对任意 $\gamma \subseteq R$，找出 $\gamma^+$。 对任意的 $S \subseteq \gamma^+$，可以输出一个函数依赖 $\gamma \to S$。

#### 正则覆盖

正则覆盖的思想是： 找到一个最小的函数依赖集 $F_c$，使得 $F_c^+ = F^+$。 什么是最小？ 就是没有无关属性。 什么是无关属性？ 就是去掉函数依赖中的一个属性，不改变该函数依赖集的闭包，则称该属性是 **无关的**。

所以正则覆盖的目标就是，去掉原始函数依赖集 $F$ 的无关属性，得到一个最小函数依赖集，称为正则覆盖。


#### 无损分解

- 令 $r(R)$ 为一个关系模式， $F$ 为 $r(R)$ 上的函数依赖集。
- 令 $R_1, R_2$ 为 $R$ 的分解。 如果用两个关系模式 $r_1(R_1)$ 和 $r_2(R_2)$ 替代 $r(R)$ 时没有信息损失，则我们称该分解是 **无损分解（lossless decomposition）**。
- 更精确的说是， 如果 $r_1(R_1)$ 和 $r_2(R_2)$ 的自然连接结果就是 $r(R)$， 则信息是无损的。 因此无损分解，也称为 **无损连接分解**。 反之称为 **有损连接分解**。

举个例子：

| $\alpha$ | $\beta$     | $\gamma$|
| :------------- | :------------- |:-----|
| $a_1$       | $b_1$       | $c_1$
| $a_2$       | $b_2$       | $c_2$

可以拆成两个关系：

| $\alpha$ | $\beta$    
| :------------- | :------------- |:-----|
| $a_1$       | $b_1$       | $c_1$
| $a_2$       | $b_2$       | $c_2$

和

| $\alpha$ |$\gamma$|
| :------------- |:-----|
| $a_1$       |  $c_1$
| $a_2$       |  $c_2$

是无损的。

但是 ：

| $\alpha$ | $\beta$     | $\gamma$|
| :------------- | :------------- |:-----|
| $a_1$       | $b_1$       | $c_1$
| $a_1$       | $b_2$       | $c_2$

拆成：
| $\alpha$ | $\beta$    
| :------------- | :------------- |:-----|
| $a_1$       | $b_1$       | $c_1$
| $a_1$       | $b_2$       | $c_2$


| $\alpha$ | $\gamma$    
| :------------- | :------------- |:-----|
| $a_1$       | $c_1$       | $c_1$
| $a_1$       | $c_2$       | $c_2$

就是有损的。它消除了$\beta$ 与 $\gamma$ 之间的关联（即 $\beta \to \gamma$ 的函数依赖）。通过自然连接恢复的关系，实际上已经不是原来的关系了。


可以用函数依赖来说明什么情况下分解是无损的： 如果以下函数依赖中至少有一个属于 $F^+$：

- $ R_1 \cap R_2 \to R_1$
- $ R_1 \cap R_2 \to R_2$

换句话说，如果 $R_1 \cap R_2$ 是 $R_1$ 或 $R_2$ 的超码，则 $R$ 上的分解就是无损分解。


#### 保持依赖

更广义的来看分解：

$F$ 为模式 $R$ 上的一个函数依赖集， $R_1, \dots, R_n$ 为 $R$ 的一个分解。 考虑 $F^+$ 同样按照 $R_1, \dots, R_n$ 属性进行分解， 为 $F_1, \dots, F_n$。  其中 $F_i$ 只有 $R_i$ 中的属性。

令 $F' = F_1 \cup F_2 \cup\cdots \cup F_n$， 如果 $F'^+ = F^+$ ，则称此分解为 **保持依赖的分解**。

还是看上面的例子，如果按照第二种分解方式，$\beta \to \gamma$ 的依赖在分解的时候丢掉了，所以不能成为 **保持依赖** 的分解。


### Boyce-Codd 范式： BCNF

具有函数依赖集 $F$ 的关系模式 $R$ 属于 BCNF 的条件是， 对 $F^+$ 中所有形如 $\alpha \to \beta$ 的函数依赖，下面至少有一项成立：

- $\alpha \to \beta$ 是平凡的函数依赖，即 $\beta \subseteq \alpha$
- $\alpha$ 是模式 $R$ 的一个超码。

一个数据库设计属于 BCNF的条件是： 构成该设计的关系模式的每个模式都属于 BCNF。

**BCNF 分解可以消除基于函数依赖能够发现的冗余。**

#### BCNF 分解的一般规则

设 $R$ 是不属于 BCNF的一个模式， 则存在至少一个非平凡的函数依赖 $\alpha \to \beta$，其中 $\alpha$ 不是 $R$ 的超码， 可以用以下两个模式取代 $R$

 - $(\alpha \cup \beta)$
 - $(R - (\beta - \alpha))$

如果分解产生的模式仍不属于 BCNF， 则可以递归进行进一步分解。

一般只有两个属性的模式，一定属于 BCNF。 所以按照这种方法的最终结果是一个 BCNF模式的集合。

#### BCNF 与保持依赖

有时候 BCNF 分解，会丢失函数依赖。由于常常希望保持依赖，因此考虑另一种比 BCNF弱的范式。该范式称为第三范式。


### 第三范式

具有函数依赖集 $F$ 的关系模式 $R$ 属于第三范式 （third normal form）的条件是： 对于 $F^+$ 中所有形如 $\alpha \to \beta$ 的函数依赖，下面至少有一项成立：

- $\alpha \to \beta$ 是平凡的函数依赖，即 $\beta \subseteq \alpha$
- $\alpha$ 是模式 $R$ 的一个超码。
- $\beta - \alpha$ 的每个属性 $A$ 都包含于 $R$ 的一个候选码中。

这多出来的第三个条件放宽了限制。虽然很不好理解。。。

> 从某种意义上，它代表 BCNF 条件的最小放宽，以确保每个模式都有保持依赖的 3NF 分解。

#### 3NF 分解

3NF 分解有算法实现（多项式时间算法。 但是判定给定关系是否属于 3NF 是 NP-hard的）


应用函数依赖进行数据库设计的目标是：

1. BCNF
2. 无损
3. 保持依赖

在不能得到保持依赖的 BCNF 分解的情况下，通常我们倾向于选择 BCNF，因为在 SQL中检查非主码约束的函数依赖很困难。


### 多值依赖与第四范式

#### 多值依赖

BCNF 在使用时仍然存在一些问题。仍然会存在信息冗余。（不再举例说明）

多值依赖记为 $\alpha \to\to \beta$。 这里不把形式化定义抄下来了。通过表格解释：

| $\alpha$ | $\beta$     | $R - \alpha - \beta$|
| :------------- | :------------- |:-----|
| $a_1$       | $b_1$       | $c_1$
| $a_1$       | $b_2$       | $c_2$
| $a_2$       | $b_2$       | $c_1$
| $a_2$       | $b_1$       | $c_2$

注意上面的关系符合 多值依赖 $\alpha \to\to \beta$。 意思是， $\alpha$ 相同，允许 $\beta$ 不同。 但是 $\alpha$ 与 $\beta$ 的联系（变化） 独立于 $\alpha$ 与 $R - \beta$ 之间的联系。

再仔细看一点，可以发现： 如果 $c_1 = c_2$， 则一定有 $b_1 = b_2$， $\alpha$ 可以作为超码使用

多值依赖的一些性质：

- 平凡的多值依赖。 如果 $\beta \subseteq \alpha$ ，则 $\alpha \to\to \beta$ 是平凡的（即总是满足）
- 如果 $\alpha \to \beta$，则 $\alpha \to\to \beta$。 函数依赖也是多值依赖
- 如果 $\alpha \to\to \beta$， 则 $\alpha \to\to R - \alpha - \beta$。
- 闭包， $D^+$


#### 第四范式

函数依赖和多值依赖集为 $D$ 的关系模式 $r(R)$ 属于 **第四范式（4NF）** 的条件是， 对 $D^+$ 中所有形如 $\alpha \to\to \beta$ 的多值依赖， 至少有以下之一成立：

- $\alpha \to\to \beta$ 是一个平凡的多值依赖
- $\alpha$ 是 $R$ 的一个超码

#### 4NF 分解

### 其他主题

- 更多的范式
    - 连接依赖（join dependency），概化多值依赖，引出另一种范式称为 投影-连接范式（PJNF）， 有些书称为第五范式
    - 域-码 范式

- E-R模型和规范化
    - 范式总体来说是数学上和形式化的概念。
    - 创建 E-R设计的过程倾向于产生 4NF设计。 这是一种设计倾向的抽象归纳和数学描述。

- 为了性能去规范化。
    - 规范化可以避免 **冗余**，保持一致性。
    - 如果去规范化，就需要额外的代码去维护数据一致性。

- 时态数据建模
    - 关于数据的历史变迁记录
    - 某些函数依赖，更完整的形式应当是随着时间变化的。


## 第九章 应用设计和开发

讲的多是web应用程序架构。 简单记一下提到的概念

- HTML， 超文本标记语言
- URL，统一资源定位符
- web服务器， HTTP通信协议
- web服务器与应用程序： 公共网关接口 CGI
- java servlet， 一种web服务器与应用程序通信的应用程序编程接口
- 服务器端脚本， 嵌入到 html， 在服务器端执行，并更新网页。
    - JSP， java server pages
    - PHP
- 客户端脚本
    - javascript
- MVC架构
- 数据库连接池，提高性能
- 单点登录
- 加密
